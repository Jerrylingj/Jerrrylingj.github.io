{"title":"基础数据结构","uid":"7ff326fdf142ec1868a8e7b87c57157c","slug":"基础数据结构","date":"2024-09-26T05:01:20.000Z","updated":"2024-09-30T08:39:21.340Z","comments":true,"path":"api/articles/基础数据结构.json","cover":"https://th.bing.com/th/id/R.abe96a9db2cbe50efe81eb818678d724?rik=zEX1OHssq3aT6w&pid=ImgRaw&r=0","content":"<h2 id=\"链表\"><a href=\"#链表\" class=\"headerlink\" title=\"链表\"></a>链表</h2><p>链表是一种线性数据结构，由一系列节点组成，每个节点包含数据部分和指向下一个节点的指针。链表的优点是插入和删除操作效率高，但随机访问的效率较低。根据节点的连接方式，链表可分为以下几种类型：</p>\n<ul>\n<li><strong>单向链表</strong>：每个节点指向下一个节点。</li>\n<li><strong>双向链表</strong>：每个节点既指向下一个节点，又指向前一个节点。</li>\n<li><strong>循环链表</strong>：最后一个节点指向头节点，形成一个环。</li>\n</ul>\n<h2 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h2><p>栈是一种后进先出（LIFO）的数据结构，插入和删除操作都发生在同一端，称为栈顶。常用的栈操作包括：</p>\n<ul>\n<li><strong>push</strong>：将元素压入栈顶。</li>\n<li><strong>pop</strong>：从栈顶弹出元素。</li>\n<li><strong>peek</strong>：查看栈顶元素但不弹出。</li>\n</ul>\n<p>栈在函数调用管理、表达式求值等场景中广泛应用。</p>\n<h2 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h2><p>队列是一种先进先出（FIFO）的数据结构，插入操作发生在队尾，删除操作发生在队头。常用的队列操作包括：</p>\n<ul>\n<li><strong>enqueue</strong>：将元素插入队尾。</li>\n<li><strong>dequeue</strong>：从队头删除元素。</li>\n<li><strong>front</strong>：查看队头元素但不删除。</li>\n</ul>\n<p>队列常用于任务调度、打印任务管理等场景。</p>\n<h2 id=\"堆\"><a href=\"#堆\" class=\"headerlink\" title=\"堆\"></a>堆</h2><p>堆是一种特殊的树形数据结构，满足堆性质：在最大堆中，父节点的值大于或等于其子节点的值；在最小堆中，父节点的值小于或等于其子节点的值。堆的主要特点包括：</p>\n<ul>\n<li><strong>插入</strong>：将新元素添加到堆中后，进行上浮操作维护堆性质。</li>\n<li><strong>删除</strong>：删除堆顶元素后，将最后一个元素移至堆顶，进行下沉操作维护堆性质。</li>\n</ul>\n<p>堆常用于实现优先队列和高效的排序算法（如堆排序）。</p>\n","text":"链表链表是一种线性数据结构，由一系列节点组成，每个节点包含数据部分和指向下一个节点的指针。链表的优点是插入和删除操作效率高，但随机访问的效率较低。根据节点的连接...","permalink":"/post/基础数据结构","photos":[],"count_time":{"symbolsCount":586,"symbolsTime":"1 mins."},"categories":[{"name":"数据结构","slug":"数据结构","count":4,"path":"api/categories/数据结构.json"}],"tags":[{"name":"链表","slug":"链表","count":1,"path":"api/tags/链表.json"},{"name":"栈","slug":"栈","count":1,"path":"api/tags/栈.json"},{"name":"队列","slug":"队列","count":1,"path":"api/tags/队列.json"},{"name":"堆","slug":"堆","count":1,"path":"api/tags/堆.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%93%BE%E8%A1%A8\"><span class=\"toc-text\">链表</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%A0%88\"><span class=\"toc-text\">栈</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%98%9F%E5%88%97\"><span class=\"toc-text\">队列</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A0%86\"><span class=\"toc-text\">堆</span></a></li></ol>","author":{"name":"Jerry","slug":"blog-author","avatar":"https://th.bing.com/th/id/R.7a1adf834060c41d2d476af2a5e322fd?rik=N35%2fqYx%2fr4RSog&riu=http%3a%2f%2fimg.keaiming.com%2fuploads%2fallimg%2f2020090111%2fsvaseyx4m3v.jpg&ehk=EBywhQ9emNaCt5dbn%2b%2fxbUc5yK42H8b%2ffRDsZKdVI6I%3d&risl=&pid=ImgRaw&r=0","link":"/","description":"<strong>up up up</strong>","socials":{"github":"https://github.com/Jerrylingj","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/2301_79143568?spm=1010.2135.3001.5343","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"线段树","uid":"a448dfd8ebb4408d1633f0dff8411f1c","slug":"线段树","date":"2024-09-26T05:05:40.000Z","updated":"2024-09-26T05:06:45.615Z","comments":true,"path":"api/articles/线段树.json","cover":"https://th.bing.com/th/id/R.fa3e78819de038c741076b8fddc6d160?rik=SKPOERrrNiyH%2fg&pid=ImgRaw&r=0","text":"线段树（Segment Tree）概述线段树是一种高效的数据结构，用于解决区间查询和更新问题。它能够在 (O(\\log n)) 时间复杂度内完成以下操作： 查询...","permalink":"/post/线段树","photos":[],"count_time":{"symbolsCount":538,"symbolsTime":"1 mins."},"categories":[{"name":"数据结构","slug":"数据结构","count":4,"path":"api/categories/数据结构.json"}],"tags":[{"name":"线段树","slug":"线段树","count":1,"path":"api/tags/线段树.json"}],"author":{"name":"Jerry","slug":"blog-author","avatar":"https://th.bing.com/th/id/R.7a1adf834060c41d2d476af2a5e322fd?rik=N35%2fqYx%2fr4RSog&riu=http%3a%2f%2fimg.keaiming.com%2fuploads%2fallimg%2f2020090111%2fsvaseyx4m3v.jpg&ehk=EBywhQ9emNaCt5dbn%2b%2fxbUc5yK42H8b%2ffRDsZKdVI6I%3d&risl=&pid=ImgRaw&r=0","link":"/","description":"<strong>up up up</strong>","socials":{"github":"https://github.com/Jerrylingj","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/2301_79143568?spm=1010.2135.3001.5343","juejin":"","customs":{}}}},"next_post":{"title":"二分","uid":"8038215b5c2b5aa82664c7d7c50d2cdc","slug":"二分","date":"2024-09-26T02:50:13.000Z","updated":"2024-10-01T09:54:24.945Z","comments":true,"path":"api/articles/二分.json","cover":"https://n.sinaimg.cn/sinacn10112/181/w1550h1031/20191218/3315-ikvenft9359266.jpg","text":"二分 注意 ❗❗❗❗二分查找的前提是被查找的数据必须有二段性 如何理解这句话呢？ 举个例子，在数组[1, 5 , 8, 9, 23, 25, 40]里找9 我可...","permalink":"/post/二分","photos":[],"count_time":{"symbolsCount":"5.1k","symbolsTime":"5 mins."},"categories":[{"name":"算法","slug":"算法","count":8,"path":"api/categories/算法.json"}],"tags":[{"name":"基础算法","slug":"基础算法","count":2,"path":"api/tags/基础算法.json"},{"name":"二分","slug":"二分","count":1,"path":"api/tags/二分.json"}],"author":{"name":"Jerry","slug":"blog-author","avatar":"https://th.bing.com/th/id/R.7a1adf834060c41d2d476af2a5e322fd?rik=N35%2fqYx%2fr4RSog&riu=http%3a%2f%2fimg.keaiming.com%2fuploads%2fallimg%2f2020090111%2fsvaseyx4m3v.jpg&ehk=EBywhQ9emNaCt5dbn%2b%2fxbUc5yK42H8b%2ffRDsZKdVI6I%3d&risl=&pid=ImgRaw&r=0","link":"/","description":"<strong>up up up</strong>","socials":{"github":"https://github.com/Jerrylingj","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/2301_79143568?spm=1010.2135.3001.5343","juejin":"","customs":{}}}}}