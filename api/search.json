[{"id":"52c3d43467d5b3dc99c6cd71203838c1","title":"动态规划--状态压缩DP","content":"","slug":"动态规划-状态压缩DP","date":"2024-09-26T05:12:44.000Z","categories_index":"","tags_index":"","author_index":"Jerry"},{"id":"e9c911dbfeb3b82e631b7a70a15f2cf2","title":"动态规划--区间DP","content":"","slug":"动态规划-区间DP","date":"2024-09-26T05:12:32.000Z","categories_index":"","tags_index":"","author_index":"Jerry"},{"id":"62555a6f14b066c1f526e128e3c72f4d","title":"动态规划--线性DP","content":"","slug":"动态规划-线性DP","date":"2024-09-26T05:12:20.000Z","categories_index":"","tags_index":"","author_index":"Jerry"},{"id":"398687178e2ec3c1a9498d5422c75757","title":"动态规划--背包问题","content":"","slug":"动态规划-背包问题","date":"2024-09-26T05:12:09.000Z","categories_index":"","tags_index":"","author_index":"Jerry"},{"id":"c3878449dce899402d13b06cc735de00","title":"博弈论--NIM游戏","content":"引入先介绍几个概念\n1.公平组合游戏ICG：\n两名玩家交替行动\n在任意时刻，可执行的行动与玩家本身无关（游戏公平性）\n不能行动的玩家输\n\n2.有向图游戏\n给定一个有向无环图，具有唯一的起点，玩家交替的把棋子沿有向边进行移动，每次移动一步，无法移动者输\n任何ICG均可化为有向图游戏\n\n3.先手必胜与先手必败\n在双方均完全理性的情况下，先手不必胜则必败，先手不必败则必胜\n\nNIM游戏：1.介绍NIM 游戏是一种经典的组合博弈，两名玩家轮流从若干堆石子中选择一堆，并从中取走任意数量的石子。无法继续操作的玩家判负。\n2.结论对堆石子\n先手必胜态：\n先手必败态：\n3.证明：由数学归纳，从特殊推向一般\n不能操作时，每堆都是，\n\n当，任意一步操作之后\n反证：对任意一步操作使\n若，\n设\n则\n则，但是，矛盾！！得证\n\n当，一定存在一步操作之后\n证明：设，设的最高位在第位\n则中必定存在至少的第位也为，且\n（若第位均为，则所有异或之后得到的第位也只能是，不合题意）\n所以可以从中拿走个石子（上一步证明了此步的合法性）\n故，得证\n\n所以在双方绝对理性的情况下，某一方拿完之后达到了异或值为的情况后，会一直握住这个状态，\n保证自己必胜。\n更详细的思路构造过程及证明请看编程之美_1.11 NIM（1）一排石头的游戏在线阅读\nSG函数\n如果文中有任何错误之处，欢迎大家在评论区批评指正！🙏\n\n\n1.Mex运算：设表示一个非负整数集合，定义为求出不属于集合的最小非负整数的运算，\n即：且\n2.SG函数将游戏的所有状态及其转换关系抽象成一张有向无环图\n定义终点，\n示例：\n\n图中模拟一堆个数为的石子的状态转移图，每次只能拿个或个石子，蓝色字为石子数，红色字为 \n对应状态的值\n \n由图：任何一个非状态都可以到，任何一个状态都到不了\n则先手拿完后对手总有办法后手让先手必败\n先手总有办法拿完使对手怎么拿都使先手必胜\n\n性质：\n对一个含多个图的游戏，取每个图起点的值\n则必胜，当\n必败，当\n3.证明：类似一般游戏\n，没有必胜的起点，则，必败\n\n\n如果文中有任何错误之处，欢迎大家在评论区批评指正！🙏\n\n\n存在，则我先手一定可以走一步到达，此时，对方 \n先手必败，即我方必胜\n\n：不全为的情况\n不管怎么走，，必将落入对方先手必胜局面，即我方必败\n分类NIM博弈的内容大致就这么多啦~\n来几道题目练练手,看看题目中是怎么变形的~\n基础变形\n洛谷 P1247 取火柴游戏\n洛谷 P7589 黑白棋        关键在翻译题目，本质就是简单的nim游戏\nP5675 取石子游戏         背包DP + 阶梯nim，代码不难理解，关键是想明白思路，考思维\n阶梯 Nim\nP3480 KAM-Pebbles    差分数组的阶梯nim\nP2575 高手过招\n\n\n如果文中有任何错误之处，欢迎大家在评论区批评指正！🙏\n\n","slug":"博弈论-NIM游戏","date":"2024-09-26T05:11:45.000Z","categories_index":"算法","tags_index":"博弈论,NIM游戏,SG函数","author_index":"Jerry"},{"id":"9fc7aaa29955e8777b63cdc5e2f3c111","title":"快速幂","content":"","slug":"快速幂","date":"2024-09-26T05:11:31.000Z","categories_index":"","tags_index":"","author_index":"Jerry"},{"id":"bb7fb6071a1bfe6c506396917992c585","title":"数学--欧拉函数","content":"","slug":"数学-欧拉函数","date":"2024-09-26T05:11:06.000Z","categories_index":"","tags_index":"","author_index":"Jerry"},{"id":"40241814551b223b651e15683e69d116","title":"数学--约数","content":"","slug":"数学-约数","date":"2024-09-26T05:10:57.000Z","categories_index":"","tags_index":"","author_index":"Jerry"},{"id":"6390ac85391cd221383c57783115e1e4","title":"数学--质数","content":"质数\n\n\n\n\n\n\n\n\n&gt;1 只包含1和本身两个约数\n1.判断质数试除法，只需枚举即可\n代码：\n12345678bool is_prime(int n){    if (n &lt; 2) return false;    for (int i = 2; i &lt;= n / i; i ++ )        if (x % i == 0)            return false;    return true;}\n细节\n①不推荐写要调用函数，太慢\n②不推荐写当太大时有可能溢出\n2.分解质因数最多只含一个的质因子，还是试除法，遇到约数就约掉\n如果约掉了所有的质因子之后仍，则约剩下的数必是质因子，单独处理即可\n代码：\n12345678910111213void divide(int n){    for (int i = 2; i &lt;= n / i; i ++ )        if (n % i == 0)        {            // 约掉所有因子，易证从小到大约掉的因子必是质因子            int s = 0;            while (x % i == 0) x /= i, s ++ ;            cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; s &lt;&lt; endl; // 输出质因子及其个数        }    if (x &gt; 1) cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; 1 &lt;&lt; endl; // 单独处理最后一个因子    cout &lt;&lt; endl;}\n3.筛质数给一个范围筛掉范围内所有的质数\n朴素筛法思路：\n从枚举，依次筛掉倍数，倍数，倍数，\n埃氏筛法优化：\n只筛掉质数的倍数，如在中枚举到，已经在的时候就被筛了，就跳过不再筛的倍数了\n显然，如果枚举到某个数，在前面没被筛掉则必是质数 \n缺点：仍旧还是有些数被重复筛了，如会被和同时筛掉，效率仍待提高\n线性筛法优化：每个数只会被自己最小质因子筛掉，如在上面只会被筛掉\n伪代码：\n①一定是最小质因子一定是最小质因子\n②一定小于的所有质因子也一定是最小质因子\n③按照此逻辑来决定一个数一个数筛\n代码：\n123456789101112131415int primes[N], cnt;     // primes[]存储所有素数bool st[N];         // st[x]存储x是否被筛掉void get_primes(int n){    for (int i = 2; i &lt;= n; i ++ )    {        if (!st[i]) primes[cnt ++ ] = i;        for (int j = 0; primes[j] &lt;= n / i; j ++ )        {            st[primes[j] * i] = true;            if (i % primes[j] == 0) break;        }    }}\n\n\n如果文中有任何错误之处，欢迎大家在评论区批评指正！🙏\n\n","slug":"数学-质数","date":"2024-09-26T05:10:48.000Z","categories_index":"算法","tags_index":"质数,数论","author_index":"Jerry"},{"id":"ecb6a8e25b500203d6f41dd2b9a24935","title":"图论--最小生成树","content":"","slug":"图论-最小生成树","date":"2024-09-26T05:09:52.000Z","categories_index":"","tags_index":"","author_index":"Jerry"},{"id":"23e5ccb93b471aba058840eff980504f","title":"图论--最短路","content":"最短路先贴张总体图：\n\n1.单源最短路(1)边权均为正数①朴素Dijkstra算法思路：\n\ndist[i]存到起点的最短距离（在执行过程更新），st[i]存是否已确定最短距离\n集合S已经确定最短距离的点集（实际上就是st[]为true的点）\n初始化所有点到起点距离均为无穷大，将起点到起点距离设置为0\n找当前所有未定最短距的点中的最近点t，用t更新其他点最短距离，并将t丢进集合S里\n迭代n次，即可确定所有点最短路\n\n步骤：\n下面用一个具体的例子来辅助解释这个过程\n\n初始化\n\n\n\n起点到起点的距离为，即\n\n\n\n遍历数组，找到一个节点，这个节点是：没有确定最短路的节点中距离起点最近的点。\n假设该节点编号为，此时就找到了起点到该节点的最短距离，置为\n\n\n\n\n遍历所有可以到达的节点，如果大于加上的距离\n即（为的距离），则更新\n\n\n\n\n一直重复上面的步骤直至所有点的最短路均被确定\n\n\n\n此时起点到所有点的最短路均被确定\n\n\n注意事项：\n复杂度：遍历次遍历个点找最近点\n稠密图，邻接矩阵存有向图\n当前情况需要每个点要求第一次出队的时候就已经确定最短路，所以要求图内不能有负权边\n（否则第一次出队可能不是最短路，则当前算法失效）\n伪代码：\n12345678int dist[n],state[n];dist[1] = 0, state[1] = 1;for(i:1 ~ n){    t &lt;- 没有确定最短路径的节点中距离源点最近的点;    state[t] = 1;    更新 dist;}\n代码模板：\n123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;int n;\t\t  // 点数int d[N][N];  // 邻接矩阵存有向图int dist[N];  // 存储1号点到每个点的最短距离bool st[N];   // 存储每个点的最短路是否已经确定// 求1号点到n号点的最短路，如果不存在则返回-1int dijkstra(){    memset(dist, 0x3f, sizeof dist);    dist[1] = 0;    for (int i = 0; i &lt; n - 1; i ++ )    {        int t = -1;     // 在还未确定最短路的点中，寻找距离最小的点        for (int j = 1; j &lt;= n; j ++ )            if (!st[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j]))                t = j;        // 用t更新其他点的距离        for (int j = 1; j &lt;= n; j ++ )            dist[j] = min(dist[j], dist[t] + d[t][j]);        st[t] = true;    }    if (dist[n] == 0x3f3f3f3f) return -1;    return dist[n];}\n②堆优化版Dijkstra算法思路：\n\n容易发现在朴素Dijkstra算法中，通过枚举来找最近点的操作值得优化，这里采用小根堆来存所有点当前离起点的最短路，堆顶即为最近点，这步操作的复杂度仅为 \n其余仍与朴素Dijkstra一样\n\n注意事项： \n复杂度：稀疏图，邻接表存有向图\n代码模板：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;typedef pair&lt;int, int&gt; PII;int n;      \t\t\t\t\t\t// 点的数量int h[N], w[N], e[N], ne[N], idx;   // 邻接表存储所有边int dist[N];        \t\t\t\t// 存储所有点到1号点的距离bool st[N];    \t\t\t\t\t \t// 存储每个点的最短距离是否已确定// 初始化邻接表void init(){    memset(h, -1, sizeof h);}// 连接有向边a→bvoid add(int a, int b, int c){    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;}// 求1号点到n号点的最短距离，如果不存在，则返回-1int dijkstra(){    memset(dist, 0x3f, sizeof dist); // 初始化距离为无穷大    dist[1] = 0;    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap; // 小根堆    heap.push({0, 1});      // first存储距离，second存储节点编号    while (heap.size())    {        auto t = heap.top(); // 取出最近点        heap.pop();        int ver = t.second, distance = t.first;        if (st[ver]) continue;        st[ver] = true;        for (int i = h[ver]; i != -1; i = ne[i])        {            int j = e[i];            if (dist[j] &gt; distance + w[i])            {                dist[j] = distance + w[i];                heap.push({dist[j], j});            }        }    }    if (dist[n] == 0x3f3f3f3f) return -1;    return dist[n];}\n！思考：为何Dijkstra只对非负权边有效，能举出例子证明吗？\n(2)存在负权边①Bellman-Ford算法思路：\n注意事项：\n\n复杂度\n\n代码模板：\n123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;int n, m;       // n表示点数，m表示边数int dist[N];        // dist[x]存储1到x的最短路距离struct Edge     // 边，a表示出点，b表示入点，w表示边的权重{    int a, b, w;}edges[M];// 求1到n的最短路距离，如果无法从1走到n，则返回-1。int bellman_ford(){    memset(dist, 0x3f, sizeof dist);    dist[1] = 0;    // 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。    for (int i = 0; i &lt; n; i ++ )    {        for (int j = 0; j &lt; m; j ++ )        {            int a = edges[j].a, b = edges[j].b, w = edges[j].w;            if (dist[b] &gt; dist[a] + w)                dist[b] = dist[a] + w;        }    }    if (dist[n] &gt; 0x3f3f3f3f / 2) return -1;    return dist[n];}\n②SPFA算法思路：\n注意事项：\n\n复杂度一般，最多\n代码短，非负权边的情况一般也能用，但是容易被卡，建议还是在存在负权边时才用\n要求一定不含负环！！！！！\n\n代码模板：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;int n;      \t\t\t\t\t\t\t// 总点数int h[N], w[N], e[N], ne[N], idx;       // 邻接表存储所有边int dist[N];        \t\t\t\t\t// 存储每个点到1号点的最短距离bool st[N];     \t\t\t\t\t\t// 存储每个点是否在队列中void init(){    memset(h, -1, sizeof h);}// 连接a→b的有向边void add(int a,int b, int c){    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;}// 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1int spfa(){    memset(dist, 0x3f, sizeof dist);    dist[1] = 0;    queue&lt;int&gt; q;    q.push(1);    st[1] = true;    while (q.size())    {        auto t = q.front();        q.pop();        st[t] = false;        for (int i = h[t]; i != -1; i = ne[i])        {            int j = e[i];            if (dist[j] &gt; dist[t] + w[i])            {                dist[j] = dist[t] + w[i];                if (!st[j])     // 如果队列中已存在j，则不需要将j重复插入                {                    q.push(j);                    st[j] = true;                }            }        }    }    if (dist[n] == 0x3f3f3f3f) return -1;    return dist[n];}\n2.多源最短路Floyd算法思路：注意事项：代码：1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int INF = 0x3f3f3f3f;int d[N][N]; // 邻接矩阵存距离// 初始化void init(){\tfor (int i = 1; i &lt;= n; i ++ )        for (int j = 1; j &lt;= n; j ++ )            if (i == j) d[i][j] = 0;            else d[i][j] = INF;}// 算法结束后，d[a][b]表示a到b的最短距离void floyd(){    for (int k = 1; k &lt;= n; k ++ )        for (int i = 1; i &lt;= n; i ++ )            for (int j = 1; j &lt;= n; j ++ )                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);}\n","slug":"图论-最短路","date":"2024-09-26T05:09:40.000Z","categories_index":"算法","tags_index":"最短路,图论,Dijkstra,SPFA,Bellman-Ford,Floyd","author_index":"Jerry"},{"id":"708fa6adfa46361c793158b58a61f772","title":"bfs","content":"","slug":"bfs","date":"2024-09-26T05:09:28.000Z","categories_index":"","tags_index":"","author_index":"Jerry"},{"id":"c0864a7ed82c2e6dd4eb8a34dacd4941","title":"dfs","content":"","slug":"dfs","date":"2024-09-26T05:09:23.000Z","categories_index":"","tags_index":"","author_index":"Jerry"},{"id":"f897c3d44f1ea027302ceab6694fc628","title":"单调队列与单调栈","content":"","slug":"单调队列与单调栈","date":"2024-09-26T05:09:03.000Z","categories_index":"","tags_index":"","author_index":"Jerry"},{"id":"c18469ab20e7b093d36b4a61728d07eb","title":"并查集","content":"并查集（Union-Find）概述并查集是一种高效的数据结构，以多棵树的形式存储，每棵树有一个被打上标记的根节点\n主要用途：\n\n合并两个集合\n查询元素所属的集合\n\n常见题型：\n\n朴素并查集\n带权并查集\n维护size并查集\n\n数据结构并查集通常使用三个数组实现：\n\np[] (parent)数组：记录每个元素的父节点。\nd[] (distanse)数组：记录每个元素到父节点距离\nsize[]数组：记录每个并查集的大小\n\nps:虽然并查集在逻辑结构上是一棵棵在同一集合的树，但是存储结构仍可以用普通的数组实现\n操作1.建立初始化并查集\n并查集根节点root:的标记方式p[root] = root\n表示根节点的父节点就是自己\n123456void init()&#123;\t// 一开始每个节点各自为营\tfor (int i = 1; i &lt;= n; i ++ )\t\tp[i] = i;&#125; \n2.查找查找元素 x 所在集合的根节点：\n这里有个优化，利用递归在查找的时候就直接把每个节点的父节点压缩向了祖宗节点，此时距离d也更新为了到父节点(祖宗节点)的距离\n1234567891011int find(int x)&#123;    if (p[x] != x) p[x] = find(p[x]);    // p[x]效果为找x的祖宗节点    // 这里调用p[x] = find(p[x])直接让x的父节点指向了p[x]的祖宗节点    // 经过层层递归会最终指向整棵树的根节点    int root = find(p[x]);     // 先要存root是因为只有先跑find()才能让d[p[x]]变为p[x]到祖宗节点的距离    d[x] += d[p[x]];    return root;&#125;\n3.合并合并两棵树：\n12345678910111213void merge(int x, int y)&#123;\t// 找出两棵树的根节点\tint px = find(x), py = find(y);\t\t// 根节点不同才需要合并\tif (px != py)     &#123;\t\tp[px] = py;        size[py] += size[px];        // 可能还需要对d[px]进行操作,具体情形依题目而定\t&#125;&#125;\n至此，并查集的基本操作均已介绍完毕，操作简洁作用大，用处这么大的数据结构上哪里找呀~\n来几道例题尝试尝试~\n例题朴素并查集\n洛谷 P3367 【模板】并查集\n\n维护size的并查集\n洛谷P1455 搭配购买\n\n维护到祖宗节点距离的并查集(带权并查集)\n 洛谷P1196 银河英雄传说\n 洛谷P2024食物链 \n\n\n如果文中有任何错误之处，欢迎大家在评论区批评指正！🙏\n\n\n\n","slug":"并查集","date":"2024-09-26T05:08:52.000Z","categories_index":"数据结构","tags_index":"并查集","author_index":"Jerry"},{"id":"52296d4e1e538f3ec200aa2ca9533c17","title":"哈希表","content":"","slug":"哈希表","date":"2024-09-26T05:08:38.000Z","categories_index":"","tags_index":"","author_index":"Jerry"},{"id":"a448dfd8ebb4408d1633f0dff8411f1c","title":"线段树","content":"线段树（Segment Tree）概述线段树是一种高效的数据结构，用于解决区间查询和更新问题。它能够在 (O(\\log n)) 时间复杂度内完成以下操作：\n\n查询区间和\n更新区间元素\n\n线段树特别适用于需要频繁处理区间查询和动态更新的场景。\n数据结构线段树通常使用完全二叉树的形式存储，节点表示数组的不同区间。假设原数组为 A，线段树为 ST，则每个节点 ST[node] 表示数组 A 的某个区间的值。\n操作1. 建树操作构建线段树的过程如下：\n```pythondef build(A, ST, node, start, end):    if start == end:        ST[node] = A[start]  # 叶子节点    else:        mid = (start + end) // 2        build(A, ST, 2  node + 1, start, mid)  # 构建左子树        build(A, ST, 2  node + 2, mid + 1, end)  # 构建右子树        ST[node] = ST[2  node + 1] + ST[2  node + 2]  # 计算节点值\n","slug":"线段树","date":"2024-09-26T05:05:40.000Z","categories_index":"数据结构","tags_index":"线段树","author_index":"Jerry"},{"id":"7ff326fdf142ec1868a8e7b87c57157c","title":"基础数据结构","content":"链表链表是一种线性数据结构，由一系列节点组成，每个节点包含数据部分和指向下一个节点的指针。链表的优点是插入和删除操作效率高，但随机访问的效率较低。根据节点的连接方式，链表可分为以下几种类型：\n\n单向链表：每个节点指向下一个节点。\n双向链表：每个节点既指向下一个节点，又指向前一个节点。\n循环链表：最后一个节点指向头节点，形成一个环。\n\n栈栈是一种后进先出（LIFO）的数据结构，插入和删除操作都发生在同一端，称为栈顶。常用的栈操作包括：\n\npush：将元素压入栈顶。\npop：从栈顶弹出元素。\npeek：查看栈顶元素但不弹出。\n\n栈在函数调用管理、表达式求值等场景中广泛应用。\n队列队列是一种先进先出（FIFO）的数据结构，插入操作发生在队尾，删除操作发生在队头。常用的队列操作包括：\n\nenqueue：将元素插入队尾。\ndequeue：从队头删除元素。\nfront：查看队头元素但不删除。\n\n队列常用于任务调度、打印任务管理等场景。\n堆堆是一种特殊的树形数据结构，满足堆性质：在最大堆中，父节点的值大于或等于其子节点的值；在最小堆中，父节点的值小于或等于其子节点的值。堆的主要特点包括：\n\n插入：将新元素添加到堆中后，进行上浮操作维护堆性质。\n删除：删除堆顶元素后，将最后一个元素移至堆顶，进行下沉操作维护堆性质。\n\n堆常用于实现优先队列和高效的排序算法（如堆排序）。\n","slug":"基础数据结构","date":"2024-09-26T05:01:20.000Z","categories_index":"数据结构","tags_index":"链表,栈,队列,堆","author_index":"Jerry"},{"id":"36ef81d64d1d0edc64820d5afd16a0b4","title":"树状数组","content":"树状数组（Fenwick Tree）概述树状数组是一种用于高效处理动态数组中前缀和查询的数据结构。它能够在 (O(\\log n)) 时间复杂度内完成以下操作：\n\n更新数组中的元素O(logn)\n查询数组前缀和O(logn)\n\n数组： O(1) 更新，O(n) 前缀和\n前缀和数组：  O(n) 更新，O(1) 前缀和\n如果问题同时要大量更新和求前缀和，上述两种数据结构均会寄掉\n树状数组则采取折中思路，把整体复杂度降低至O(logn)\n数据结构先放张整体结构图：\n\n核心思想：二进制\n对任意数x可将其二进制分解\n\nx = 2^{i_k} + 2^{i_{k-1}} + 2^{i_{k-2}} + \\cdots + 2^{i_1}\n\\text{其中}i_k>i_{k-1}>i_{k-2}>\\cdots>i_1从而将区间(0, x]分为以下几个部分：\n长度\n长度\n长度\n长度\n容易发现，对于任意一段区间(L,R]\n区间长度为lowbit(x),区间左端点L = R - lowbit(R)\n则在上述规则下，只要确定右端点，左端点的信息也唯一确定\n\n树状数组用一个数组来存储序列的信息:\ntr[x]：存储序列在[x - lowbit(x) + 1, x]之间的数的片段和\n则按照前面的区间划分规则\n\n\\begin{aligned}\n\\sum_{i = 1}^x{a[i]} & = \\sum_{i=x-2^{i_1}+1}^x{a[i]} + \\sum_{i=x-2^{i_1}-2^{i_2}+1}^{x-2^{i_1}}{a[i]} + \\cdots + \\sum_{i=1}^{2^{i_k}}{a[i]}\\\\\n& = tr[x] + tr[x-2^{i_1}] + \\cdots + tr[2^{i_k}]\\\\\n& = tr[x] + tr[x-\\text{lowbit}(x)] + tr[(x-\\text{lowbit}(x))-\\text{lowbit}(x-\\text{lowbit}(x))] + \\cdots\n\\end{aligned}看到公式的第三行，很容易想到可以用递归来实现，只需每层往下不断-lowbit(t)就行\nx最多只有logx位1，所以树状数组求前缀和的操作复杂度是O(logn)\n类似的，若要实现在原数组第x位上添加c\n\ntr[x], tr[x + lowbit(x)], tr[(x + lowbit(x)) + lowbit(tr[x]+lowbit(x))],\\cdots均需添加c(可能这个结论不是那么明显，读者可自行思考其中的原理，后续笔者将补充上证明)\n当然这里不会无穷往后面加，我们只需用到1~n的数据，当加到超过n就可以停了，故整该操作的复杂度仍旧为O(logn)（分析同求和\n一个更容易理解的视频讲解\n操作1. lowbit运算复杂度：O(1)\n代码如下，大家可以自行找几个数验证一下\n12345int lowbit(int x){    // 取出x的最后一位1    return x &amp; -x;}\n2.添加复杂度：O(logn)\n123456int add(int x, int c){\t// 向第x位添加c,c可正可负\t// 对所有含第x位的树节点均加上c\tfor (int i = X; i &lt;= n; i += lowbit(i)) tr[i] += c;}\n3.前缀和复杂度：O(logn)\n1234567int sum(int x){\t// 对第1~x位求和\t// 计算当前数存的值,然后迭代求剩余节点的值\tif (!x) return 0;\treturn tr[x] + sum(x - lowbit(x));}\n例题洛谷 P10589 楼兰图腾\nPOJ 2182 迷路的奶牛 \nPOJ 3468  A Simple Problem with Integers \n题解\n\\cdots\\cdots 待更新\n\n如果文中有任何错误之处，欢迎大家在评论区批评指正！🙏\n\n\n\n","slug":"树状数组","date":"2024-09-26T04:54:35.000Z","categories_index":"数据结构,算法","tags_index":"树状数组,lowbit,前缀和","author_index":"Jerry"},{"id":"8038215b5c2b5aa82664c7d7c50d2cdc","title":"二分","content":"二分\n\n\n\n\n\n\n注意\n❗❗❗❗二分查找的前提是被查找的数据必须有二段性\n\n如何理解这句话呢？\n举个例子，在数组[1, 5 , 8, 9, 23, 25, 40]里找9\n我可以让check标准为&lt;=9，则转化为找数组中&lt;=9最大值\n对于9左边的数，均小于等于9,而对于9右边的数，均大于9\n目标答案的两边一边满足check一边不满足check，这便是二段性的含义\n绝大多数时候，二段性均不明显，需要通过自行定义check标准把二段性弄出来，需要积累一定的题量\n核心思想二分查找通过不断缩小查找范围，每次将范围缩小一半，最终定位目标元素的位置。\n算法思路\n初始化边界\n\n进入二分，check(mid)\n\n重复操作\n\n\n核心：不断折半折半查找的关键在于通过不断折半查找区间，可以大幅度减少查找次数，效率为 O(log n)\n代码：\n二分的模板不唯一，关键就是要判断好循环终止条件和划分好折半区间的边界，避免死循环\n这里放一个我一直在用的模板\n整数二分\n123456789101112131415161718192021// 模板1：check选左bool check(int x)&#123;\t// 定义check标准\tif (……) return false;\treturn true;&#125;int main()&#123;    int l = L, r = R; // 初始化边界    int mid;    while (l &lt; r)    &#123;        mid = l + r &gt;&gt; 1;        if (check(mid)) r = mid;        else l = mid + 1;    &#125;    cout &lt;&lt; l &lt;&lt; endl;&#125;\n123456789101112131415161718192021// 模板2: check选右bool check(int x)&#123;\t// 定义check标准\tif (……) return false;\treturn true;&#125;int main()&#123;    int l = L, r = R;    int mid;    while (l &lt; r)    &#123;        mid = l + r + 1 &gt;&gt; 1;        if (check(mid)) l = mid;        else r = mid - 1;    &#125;    cout &lt;&lt; l &lt;&lt; endl;&#125;\n小数二分\n12345678910111213141516171819bool check(double x)&#123;\t// 定义check标准\tif (……) return false;\treturn true;&#125;int main()&#123;\tconst double eps = 1e-6; // 设置精度\tdouble l = L, r = R;\tdouble mid;\twhile (r - l &gt; eps)    &#123;    \tmid = (l + r) / 2;    \tif (check(mid)) r = mid;    \telse l = mid;    &#125;&#125;\n模板题洛谷P1083 借教室\n洛谷P3743 小鸟的设备\n洛谷P9240 冶炼金属 \n\n 如果文中有任何错误之处，欢迎大家在评论区批评指正！🙏\n\n\n","slug":"二分","date":"2024-09-26T02:50:13.000Z","categories_index":"算法","tags_index":"基础算法,二分","author_index":"Jerry"},{"id":"2a1893ca085cc0c5b7d1cdcd8c0b1c91","title":"排序","content":"1.快速排序对数组 q 在下标 l 到 r 的范围内进行升序排序。\n快速排序通过多次的比较和交换，在一趟排序之中确定好选择的基准应该在的位置。这个位置满足的条件是：\n\n它的左边的数都小于它。\n它的右边的数都大于它。\n\n之后对左右的区间进行递归排序，最后所有的数都位于它应该在的地方，排序完成。\n排序思路\n确定分界点 x ：\n\n选择 x 为 q[l]、q[r] 或 q[(l + r) / 2] 中的任意一个。\nps: x可以任取，一般取为q[ l + r &gt;&gt; 1]\n\n\n\n调整数组：\n\nq[l] 到 q[x-1] 中的元素都小于 x，\nq[x+1] 到 q[r] 中的元素都大于或等于 x。\n\n\n递归处理子区间：\n\n\n核心操作双指针：\n\n设置两个指针，i 和 j，分别指向当前区间的头和尾。\n两个指针向中间移动，遇到不满足条件的元素(需要交换)时停止。\n交换这两个指针指向的元素，然后继续移动指针，直到它们相遇。\n\n注意事项\n在判断条件时要确保准确，避免死循环→注意前面的最前面的return判断\n确定好每次递归的区间，确保排序的完整性。\n时间复杂度O(nlogn)\n\n代码：12345678910111213141516void quick_sort(int q[], int l, int r)&#123;\tif (l &gt;= r) return; // 排序完成,返回\tint x = q[l + r &gt;&gt; 1], i = l - 1, j = r + 1;\twhile (i &lt; j)    &#123;\t\t// 当两个指针未相遇时,一直移动直至需要交换    \tdo i ++; while(q[i] &lt; x);    \tdo j --; while(q[j] &gt; x);    \tif (i &lt; j) swap(q[i], q[j]); // 交换    \t    \t// 分治子区间    \tquick_sort(q, l, j);    \tquick_sort(q, j + 1, r);    &#125;&#125;\n直接理解可能还是有点抽象，也许你会觉得好像寻找分界点让左小又大能有一定的排序作用，但是get不到为什么这样一通操作能保证全体点都严格排好序，找到了张动态图给大家参考一下~\n\n2.归并排序对数组 q 在下标 l 到 r 的范围内进行升序排序。\n核心思想分治\n排序思路\n确定分界点mid：\n\nmid = (l + r) / 2，将数组分为两部分。\n\n\n递归排序：\n\n递归地对 q[l] ~ q[mid] 和 q[mid+1] ~ q[r] 两部分进行排序，此时两部分已各自有序→当前需要进行的操作仅为归并已经排好的两段区间\n\n\n合并：\n\n\n核心操作双指针：\n\n指针分别指向两部分的头部。\n比较两部分当前指针指向的元素，将较小的复制到一个新的数组中。\n当其中一部分复制完后，将另一部分剩余的元素全部复制到新数组。\n将合并后的新数组复制回原数组。\n\n注意事项\n递归时需要确保左右部分的区间划分正确。\n时间复杂度O(nlogn)\n\n代码：12345678910111213141516171819202122232425262728const int N = 1e6 + 10; // 根据具体题目定数量级int tmp[N]; // 用来临时存归并完的数组void merge_sort(int q[], int l, int r)&#123;\tif (l &gt;= r) return; // 排序完成,返回\t\tint mid = l + r &gt;&gt; 1;\t\t// 排序好子区间\tmerge_sort(q, l, mid), merge_sort(q, mid + 1, r);\t\t// 合并\tint i = l, j = mid + 1, k = 0;\tint tmp[N];\twhile (i &lt;= mid &amp;&amp; j &lt;= r)\t&#123;\t\tif (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];\t\telse tmp[k ++ ] = q[j ++ ];\t&#125;\t\twhile (i &lt;= mid) tmp[k ++ ] = q[i ++ ];\twhile (j &lt;= r) tmp[k ++ ] = q[j ++ ];\t\t// 把排完序的数组拷贝回去\tfor (i = l, k = 0; i &lt;= r;) q[i ++ ] = q[k ++ ];&#125;\n归并排序在大一的程设中也有出现喔，这里贴个图模拟一下排序的流程~\n\n排序模板题：洛谷 P1177 归并排序\n洛谷P1908 逆序对\n\n 如果文中有任何错误之处，欢迎大家在评论区批评指正！🙏\n\n","slug":"排序","date":"2024-09-26T02:05:17.000Z","categories_index":"算法","tags_index":"基础算法,快速排序,归并排序","author_index":"Jerry"},{"id":"b70cb6e2fe5cd3e70bacd823f6f633fc","title":"近期规划","content":"欢迎来到我的小天地！🎉嘿，欢迎来到我的小天地！这是一个属于技术与灵感碰撞的角落，无论你是路过还是驻足，都希望这儿能给你带来点什么有趣的东西。\n关于这个博客这个博客就像是我脑海里的“小宇宙”——技术、算法、科研，以及生活里的灵感火花。我想在这里和大家分享自己的探索，可能会有些前端、后端的技术总结，算法挑战的记录。当然，也会有一些跑步和指弹的故事。\n你可以期待什么？未来这里会不断更新关于技术的思考、算法题的解题策略，也许还会时不时出现一些指弹吉他的歌曲推荐 🎸 或者跑步时的训练随笔 🏃。你可以期待这里每一篇文章都带来一点灵感和乐趣！\n一起互动吧！如果你对某个技术话题感兴趣，或者也喜欢讨论算法问题，随时留言！我非常期待与你的互动。别害羞，我的评论区永远欢迎你！🙌\n\n好了，不多剧透了，先看文章吧！希望你每次来访都能有所收获，并愿意常来坐坐 😊。\n","slug":"近期规划","date":"2024-09-26T01:49:54.000Z","categories_index":"公告","tags_index":"","author_index":"Jerry"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post1$ hexo new &quot;My New Post&quot;\nMore info: Writing\nRun server1$ hexo server\nMore info: Server\nGenerate static files1$ hexo generate\nMore info: Generating\nDeploy to remote sites1$ hexo deploy\nMore info: Deployment\n","slug":"hello-world","date":"2024-09-25T08:52:32.921Z","categories_index":"博客","tags_index":"博客部署","author_index":"Jerry"}]