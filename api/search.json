[{"id":"8038215b5c2b5aa82664c7d7c50d2cdc","title":"二分","content":"二分❗❗❗❗二分查找的前提是被查找的数据必须是有二段性的\n如何理解这句话呢？\n举个例子，在数组[1, 5 , 8, 9, 23, 25, 40]里找9\n我可以让check标准为&lt;=9，则转化为找数组中&lt;=9最大值\n对于9左边的数，均小于等于9,而对于9右边的数，均大于9\n目标答案的两边一边满足check一边不满足check，这便是二段性的含义\n绝大多数时候，二段性均不明显，需要通过自行定义check标准把二段性弄出来，需要积累一定的题量\n核心思想二分查找通过不断缩小查找范围，每次将范围缩小一半，最终定位目标元素的位置。\n算法思路\n初始化边界：\n\n**进入二分，check(mid)**：\n\n重复操作：\n\n\n核心：不断折半折半查找的关键在于通过不断折半查找区间，可以大幅度减少查找次数，效率为 O(log n)\n代码：\n二分的模板不唯一，关键就是要判断好循环终止条件和划分好折半区间的边界，避免死循环\n这里放一个我一直在用的模板\n整数二分\n123456789101112131415161718192021// 模板1：check选左bool check(int x)&#123;\t// 定义check标准\tif (……) return false;\treturn true;&#125;int main()&#123;    int l = L, r = R; // 初始化边界    int mid;    while (l &lt; r)    &#123;        mid = l + r &gt;&gt; 1;        if (check(mid)) r = mid;        else l = mid + 1;    &#125;    cout &lt;&lt; l &lt;&lt; endl;&#125;\n\n123456789101112131415161718192021// 模板2: check选右bool check(int x)&#123;\t// 定义check标准\tif (……) return false;\treturn true;&#125;int main()&#123;    int l = L, r = R;    int mid;    while (l &lt; r)    &#123;        mid = l + r + 1 &gt;&gt; 1;        if (check(mid)) l = mid;        else r = mid - 1;    &#125;    cout &lt;&lt; l &lt;&lt; endl;&#125;\n\n\n\n小数二分\n12345678910111213141516171819bool check(double x)&#123;\t// 定义check标准\tif (……) return false;\treturn true;&#125;int main()&#123;\tconst double eps = 1e-6; // 设置精度\tdouble l = L, r = R;\tdouble mid;\twhile (r - l &gt; eps)    &#123;    \tmid = (l + r) / 2;    \tif (check(mid)) r = mid;    \telse l = mid;    &#125;&#125;\n\n\n\n模板题洛谷P1083 借教室\n洛谷P3743 小鸟的设备\n洛谷P9240 冶炼金属 \n\n如果文中有任何错误之处，欢迎大家在评论区批评指正！🙏\n","slug":"二分","date":"2024-09-26T02:50:13.000Z","categories_index":"","tags_index":"算法,二分","author_index":"Jerry"},{"id":"2a1893ca085cc0c5b7d1cdcd8c0b1c91","title":"排序","content":"1.快速排序对数组 q 在下标 l 到 r 的范围内进行升序排序。\n快速排序通过多次的比较和交换，在一趟排序之中确定好选择的基准应该在的位置。这个位置满足的条件是：\n\n它的左边的数都小于它。\n它的右边的数都大于它。\n\n之后对左右的区间进行递归排序，最后所有的数都位于它应该在的地方，排序完成。\n排序思路\n确定分界点 x ：\n\n选择 x 为 q[l]、q[r] 或 q[(l + r) / 2] 中的任意一个。\nps: x可以任取，一般取为q[ l + r &gt;&gt; 1]\n\n\n\n调整数组：\n\nq[l] 到 q[x-1] 中的元素都小于 x，\nq[x+1] 到 q[r] 中的元素都大于或等于 x。\n\n\n递归处理子区间：\n\n\n核心操作双指针：\n\n设置两个指针，i 和 j，分别指向当前区间的头和尾。\n两个指针向中间移动，遇到不满足条件的元素(需要交换)时停止。\n交换这两个指针指向的元素，然后继续移动指针，直到它们相遇。\n\n注意事项\n在判断条件时要确保准确，避免死循环→注意前面的最前面的return判断\n确定好每次递归的区间，确保排序的完整性。\n时间复杂度O(nlogn)\n\n代码：12345678910111213141516void quick_sort(int q[], int l, int r)&#123;\tif (l &gt;= r) return; // 排序完成,返回\tint x = q[l + r &gt;&gt; 1], i = l - 1, j = r + 1;\twhile (i &lt; j)    &#123;\t\t// 当两个指针未相遇时,一直移动直至需要交换    \tdo i ++; while(q[i] &lt; x);    \tdo j --; while(q[j] &gt; x);    \tif (i &lt; j) swap(q[i], q[j]); // 交换    \t    \t// 分治子区间    \tquick_sort(q, l, j);    \tquick_sort(q, j + 1, r);    &#125;&#125;\n\n直接理解可能还是有点抽象，也许你会觉得好像寻找分界点让左小又大能有一定的排序作用，但是get不到为什么这样一通操作能保证全体点都严格排好序，找到了张动态图给大家参考一下~\n\n2.归并排序对数组 q 在下标 l 到 r 的范围内进行升序排序。\n核心思想分治\n排序思路\n确定分界点mid：\n\nmid = (l + r) / 2，将数组分为两部分。\n\n\n递归排序：\n\n递归地对 q[l] ~ q[mid] 和 q[mid+1] ~ q[r] 两部分进行排序，此时两部分已各自有序→当前需要进行的操作仅为归并已经排好的两段区间\n\n\n合并：\n\n\n核心操作双指针：\n\n指针分别指向两部分的头部。\n比较两部分当前指针指向的元素，将较小的复制到一个新的数组中。\n当其中一部分复制完后，将另一部分剩余的元素全部复制到新数组。\n将合并后的新数组复制回原数组。\n\n注意事项\n递归时需要确保左右部分的区间划分正确。\n时间复杂度O(nlogn)\n\n代码：12345678910111213141516171819202122232425262728const int N = 1e6 + 10; // 根据具体题目定数量级int tmp[N]; // 用来临时存归并完的数组void merge_sort(int q[], int l, int r)&#123;\tif (l &gt;= r) return; // 排序完成,返回\t\tint mid = l + r &gt;&gt; 1;\t\t// 排序好子区间\tmerge_sort(q, l, mid), merge_sort(q, mid + 1, r);\t\t// 合并\tint i = l, j = mid + 1, k = 0;\tint tmp[N];\twhile (i &lt;= mid &amp;&amp; j &lt;= r)\t&#123;\t\tif (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];\t\telse tmp[k ++ ] = q[j ++ ];\t&#125;\t\twhile (i &lt;= mid) tmp[k ++ ] = q[i ++ ];\twhile (j &lt;= r) tmp[k ++ ] = q[j ++ ];\t\t// 把排完序的数组拷贝回去\tfor (i = l, k = 0; i &lt;= r;) q[i ++ ] = q[k ++ ];&#125;\n\n归并排序在大一的程设中也有出现喔，这里贴个图模拟一下排序的流程~\n\n排序模板题：洛谷 P1177 归并排序\n洛谷P1908 逆序对\n\n如果文中有任何错误之处，欢迎大家在评论区批评指正！🙏\n","slug":"排序","date":"2024-09-26T02:05:17.000Z","categories_index":"","tags_index":"算法,快速排序,归并排序","author_index":"Jerry"},{"id":"b70cb6e2fe5cd3e70bacd823f6f633fc","title":"近期规划","content":"欢迎来到我的小天地！🎉嘿，欢迎来到我的小天地！这是一个属于技术与灵感碰撞的角落，无论你是路过还是驻足，都希望这儿能给你带来点什么有趣的东西。\n关于这个博客这个博客就像是我脑海里的“小宇宙”——技术、算法、科研，以及生活里的灵感火花。我想在这里和大家分享自己的探索，可能会有些前端、后端的技术总结，算法挑战的记录，还有数学建模的心得。当然，也会有一些跑步和吉他的故事。\n你可以期待什么？未来这里会不断更新关于技术的思考、算法题的解题策略，也许还会时不时出现一些指弹吉他的歌曲推荐 🎸 或者跑步时的训练随笔 🏃。你可以期待这里每一篇文章都带来一点灵感和乐趣！\n一起互动吧！如果你对某个技术话题感兴趣，或者也喜欢讨论算法问题，随时留言！我非常期待与你的互动。别害羞，我的评论区永远欢迎你！🙌\n\n好了，不多剧透了，先看文章吧！希望你每次来访都能有所收获，并愿意常来坐坐 😊。\n","slug":"近期规划","date":"2024-09-26T01:49:54.000Z","categories_index":"","tags_index":"公告","author_index":"Jerry"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post1$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server1$ hexo server\n\nMore info: Server\nGenerate static files1$ hexo generate\n\nMore info: Generating\nDeploy to remote sites1$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2024-09-25T08:52:32.921Z","categories_index":"","tags_index":"博客部署","author_index":"Jerry"}]