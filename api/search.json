[{"id":"d6ffd179ab68b0daa56addeeaeb71166","title":"GPT获取sso信息出错","content":"尝试登陆GPT账号发现报错rt\n\n\n解决\n在网址的“auth”中加个0，改成https://auth0.openai.com//authorize?client这种形式再登录。\n\n\n正常登录\n","slug":"GPT获取sso信息出错","date":"2024-09-30T08:43:11.000Z","categories_index":"","tags_index":"GPT","author_index":"Jerry"},{"id":"bbe13304b560081099040d9e49fec292","title":"初级实训作业1-贪吃蛇","content":"\n\n\n\n\n\n\n\n\nQt实现，为避免雷同，展示大致的思路及部分效果图~\n其实之前已经写过一个贪吃蛇小游戏网站了，可惜当时重心放在后端的匹配系统和贪吃蛇bot的代码运行上，前端做的稍微简陋了一点\n这次恰好利用Qt，把整体游戏界面做的更丰满一些o(￣▽￣)ブ\n1.安装Qt参考教程\n2.创建项目\n\n\n\n\n\n\n构建系统—qmake\nDetails—Base class—QWidget\n\n\n\n\n新项目创建完毕\n\n\n运行效果—白框框\n3.整体设计蛇身 + 地图 + 道具掉落（种类多设计一点） +生命值 + 计分板 + 难度调节器（调节速度）\n设计：初始设定：积分 0\n道具：\n①food：长度+1，积分+10\n②wall：障碍物 碰到停止\n③咬到自己：死\n基本流程：①调节难度，开始游戏\n②读取键盘输入\n②处理方向更新\n③处理蛇身更新\n④处理道具更新\n⑤判断是否死亡\n⑥全体布局确定，渲染地图\n部分效果图如下：\n\n\n4.Code(1)基本API待更新……\n","slug":"初级实训大作业1-贪吃蛇","date":"2024-09-29T15:18:32.000Z","categories_index":"小游戏","tags_index":"Qt","author_index":"Jerry"},{"id":"e9c911dbfeb3b82e631b7a70a15f2cf2","title":"动态规划--区间DP","content":"","slug":"动态规划-区间DP","date":"2024-09-26T05:12:32.000Z","categories_index":"","tags_index":"","author_index":"Jerry"},{"id":"62555a6f14b066c1f526e128e3c72f4d","title":"动态规划--线性DP","content":"","slug":"动态规划-线性DP","date":"2024-09-26T05:12:20.000Z","categories_index":"算法","tags_index":"动态规划,线性DP","author_index":"Jerry"},{"id":"398687178e2ec3c1a9498d5422c75757","title":"动态规划--背包问题","content":"🎮 背包问题欢迎来到 动态规划的冒险世界！在这趟旅途中，你将化身为一位勇敢的冒险者，面临一个经典而深邃的挑战：如何在有限的资源下获得最大的收益。每一关都充满了挑战，但只要你步步为营，掌握算法精髓，最终你会成为背包问题的 算法大师。准备好了吗？Let’s Go!\n\n前言背包问题是动态规划最经典的问题之一，在这里，我们初步学会如何使用动态规划解决问题\n绝大部分情况下，动态规划步骤如下：\n状态表示：集合描述\n状态计算：划分集合，把当前状态转化为子集状态（注意不重不漏）进而写出状态转移方程\n接下来，让我们到题目中理解这两步的含义吧！\n分类1.01背包\n种物品，体积背包\n物品体积，价值（最多只能用一次）​\n\n洛谷P1048 采药\n洛谷P1060 开心的金明\n2.完全背包\n种物品，体积背包\n物品体积，价值（无限用）\n\n洛谷P1616 疯狂的采药\n洛谷P1853 投资的最大效益\n3.多重背包\n种物品，体积背包\n物品体积，价值（每种最多选个）​\n\n洛谷P1776 宝物筛选\n4.分组背包\n组物品，体积背包\n组内每件物品体积价值每组物品种最多选个\n\n洛谷P1757 通天之分组背包\n洛谷P5322 排兵布阵\n求背包装得下的情况下的最大总价值\n讲解1.01背包\n种物品，体积背包\n物品体积，价值（最多只能用一次）\n\n思路：状态表示：前种物品花费体积得到的最大价值\n状态计算：第种物品选不选\n求最大价值：状态转移方程\n理解：从第种物品一件一件往后选，每一步都求所有体积下的最优解\n全局最优解一定会从前面的某个局部最优解转移过来\n例题：洛谷P1048 采药\n题目描述\n辰辰是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到一个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同的草药，采每一株都需要一些时间，每一株也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。”\n如果你是辰辰，你能完成这个任务吗？\n输入\n第一行有  个整数 （）和 （），用一个空格隔开， 代表总共能够用来采药的时间， 代表山洞里的草药的数目。\n接下来的  行每行包括两个在  到  之间（包括  和 ）的整数，分别表示采摘某株草药的时间和这株草药的价值。\n输出\n输出在规定的时间内可以采到的草药的最大总价值。\n样例输入\n123470 371 10069 11 2\n\n样例输出 \n13\n\n翻译题目\n总时间背包体积\n采每种药的时间物品体积\n\n状态表示：前种物品花费体积得到的最大价值\n状态计算：第种物品选不选\n求最大价值：状态转移方程\n\n代码如下：​\n1234567891011121314151617181920212223242526272829303132333435363738// 01背包// 状态表示 dp[i][j] 前i种j体积最大价值// 状态计算 dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - v[i]] + w[i])#include &lt;iostream&gt;using namespace std;const int N = 110, M = 1010;int n, V;int dp[N][M];int v[N], w[N]; // 我这里按照自己习惯定义的变量,可能和题目符号有些出入int main (){    cin &gt;&gt; V &gt;&gt; n;        for (int i = 1; i &lt;= n; i ++ )        cin &gt;&gt; v[i] &gt;&gt; w[i];        // 开始动态规划,从前往后一个一个挑    for (int i = 1; i &lt;= n; i ++ )         for (int j = 0; j &lt;= V; j ++ )        {            // 选到第i种,花费j体积            // 第i件没得选, 放不下            if (j &lt; v[i]) dp[i][j] = dp[i - 1][j];                        // 第i件有选或不选的权利            else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - v[i]] + w[i]);\t\t}        // 输出答案    cout &lt;&lt; dp[n][V] &lt;&lt; endl;        return 0;}\n\n\n\n优化还没完！还能再优化！🤭\n观察上面代码，我们发现在挑到第件物品时，我们只会用到第层的数据，而不会用到更前面的数据\n故可以把直接压缩到遍历到第种物品时，在第层的基础上更新到第层\n对于体积的直接保留原本的\n注意为了避免第层更新用的数据已经被更新过，这里体积需要从大到小枚举，读者可以自行体会\n\n优化后代码如下\n12345678910111213141516171819202122232425// 01背包1维#include &lt;iostream&gt;using namespace std;const int N = 110, M = 1010;int n, V;int dp[M];int v[N], w[N]; int main (){\tios::sync_with_stdio(false);\tcin.tie(0);\tcout.tie(0);        cin &gt;&gt; V &gt;&gt; n;    for (int i = 1; i &lt;= n; i ++ )        cin &gt;&gt; v[i] &gt;&gt; w[i];        for (int i = 1; i &lt;= n; i ++ )         for (int j = V; j &gt;= v[i]; j -- ) // 从大到小枚举,小于v[i]的更新不了        \tdp[j] = max(dp[j], dp[j - v[i]] + w[i]);        cout &lt;&lt; dp[V] &lt;&lt; endl;    return 0;}\n\n\n\n2.完全背包\n种物品，体积背包\n物品体积，价值（无限用）\n\n思路：模仿背包的思路，按照以下步骤\n状态表示：前种花体积的最大价值\n状态计算：背包的子状态是第种选没选完全背包可以无限选，子状态是第种选了个​\n转移方程：\n\n每一层都这样枚举，总体复杂度显然过于复杂了，需要进一步优化转移方程\n类似上面的，\n对比可得\n\n​\n如此一来便化简了许多\n优化：再考虑优化到维：\n第层需要用到第层和第层的数据，这不恰好是体积从小到大枚举得到的效果？\n体积从小到大枚举，第层枚举到时已经被更新为了而仍保留，符合题意\n所以和背包一样，这里也能压缩掉一维，只需体积从小到大枚举即可\n例题：洛谷P1616 疯狂的采药\n题目描述\nLiYuxiang 是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到一个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同种类的草药，采每一种都需要一些时间，每一种也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。”\n如果你是 LiYuxiang，你能完成这个任务吗？\n此题和原题的不同点：\n. 每种草药可以无限制地疯狂采摘。\n. 药的种类眼花缭乱，采药时间好长好长啊！师傅等得菊花都谢了！\n输入\n输入第一行有两个整数，分别代表总共能够用来采药的时间  和代表山洞里的草药的数目 。\n第  到第  行，每行两个整数，第  行的整数  分别表示采摘第  种草药的时间和该草药的价值。\n输出\n输出一行，这一行只包含一个整数，表示在规定的时间内，可以采到的草药的最大总价值。\n样例输入\n123470 371 10069 11 2\n\n样例输出\n1140\n\n\n\n代码如下：\n12345678910111213141516171819202122232425// 完全背包1维#include &lt;iostream&gt;using namespace std;const int N = 10010, M = 1e7+10;int n, V;long long int dp[M];long long  v[N], w[N]; int main (){\tios::sync_with_stdio(false);\tcin.tie(0);\tcout.tie(0);        cin &gt;&gt; V &gt;&gt; n;    for (int i = 1; i &lt;= n; i ++ )        cin &gt;&gt; v[i] &gt;&gt; w[i];        for (int i = 1; i &lt;= n; i ++ )         for (int j = v[i]; j &lt;= V; j ++ )        \tdp[j] = max(dp[j], dp[j - v[i]] + w[i]);        cout &lt;&lt; dp[V] &lt;&lt; endl;    return 0;}\n\n\n\n3.多重背包\n种物品，体积背包\n物品体积，价值（每种最多选个）​\n\n思路：状态表示：前种花体积的最大价值\n状态计算：子状态：第种选了个\n转移方程：\n\n总体复杂度当非常大时需要优化\n关键是从到枚举第种选了个效率太低了\n\n优化：优化思路：把第个物品用二进制拆成多种组合个个个 \n将每种物品的个单独看作一个物品\n则任意或\n进而再转化为背包问题这样对于每种物品最多只需要讨论个选与不选复杂度优化到\n思考为何这里不能用完全背包类似的优化思路\n例题：洛谷P1776 宝物筛选\n题目描述\n终于，破解了千年的难题。小 FF 找到了王室的宝物室，里面堆满了无数价值连城的宝物。\n这下小 FF 可发财了，嘎嘎。但是这里的宝物实在是太多了，小 FF 的采集车似乎装不下那么多宝物。看来小 FF 只能含泪舍弃其中的一部分宝物了。\n小 FF 对洞穴里的宝物进行了整理，他发现每样宝物都有一件或者多件。他粗略估算了下每样宝物的价值，之后开始了宝物筛选工作：小 FF 有一个最大载重为  的采集车，洞穴里总共有  种宝物，每种宝物的价值为 ，重量为 ，每种宝物有  件。小 FF 希望在采集车不超载的前提下，选择一些宝物装进采集车，使得它们的价值和最大。\n输入格式\n第一行为一个整数  和 ，分别表示宝物种数和采集车的最大载重。\n接下来  行每行三个整数 ​​。\n，，\n输出格式\n输出仅一个整数，表示在采集车不超载的情况下收集的宝物的最大价值。\n样例输入\n123454 203 9 35 9 19 4 28 1 3\n\n样例输出\n147\n\n\n\n代码如下：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 多重背包问题#include &lt;iostream&gt;using namespace std;const int N = 1e5 + 10, M = 4e4 + 10;int n, V;int dp[N];int v[N], w[N];int main(){    ios::sync_with_stdio(false);    cin.tie(0);    cout.tie(0);        cin &gt;&gt; n &gt;&gt; V;        int cnt = 1; // 存储拆分后的物品种数    int v1, w1, s1; // 未拆分    for (int i = 1; i &lt;= n; i ++ )    {        cin &gt;&gt; w1 &gt;&gt; v1 &gt;&gt; s1;                // s1拆成1+2+4+8+……        int k = 1;        while (s1 - k &gt; 0)        {            v[cnt] = v1 * k;            w[cnt ++] = w1 * k;            s1 -= k;            k *= 2;        }                // 拆剩下的        if(s1) v[cnt] = v1 * s1, w[cnt ++] = w1 * s1;\t}        n = cnt - 1;        // 01背包    for (int i = 1; i &lt;= n; i ++ )        for (int j = V; j &gt;= v[i]; j -- )        \tdp[j] = max(dp[j], dp[j - v[i]] + w[i]);        cout &lt;&lt; dp[V] &lt;&lt; endl;        return 0;}\n\n\n\n4.分组背包\n组物品，体积背包\n组内每件物品体积价值每组物品种最多选个​\n\n思路：状态表示前组花费体积的最大值\n状态计算子状态上一组选了哪一个\n状态转移方程\n\n优化至一维体积降序枚举略\n例题：洛谷P1757 通天之分组背包\n题目描述\n自  背包问世之后，小 A 对此深感兴趣。一天，小 A 去远游，却发现他的背包不同于  背包，他的物品大致可分为  组，每组中的物品相互冲突，现在，他想知道最大的利用价值是多少。\n输入\n两个数 ，表示一共有  件物品，总重量为 。\n接下来  行，每行  个数 ，表示物品的重量，利用价值，所属组数。\n，，， 在 int 范围内。\n输出\n一个数，最大的利用价值。\n样例输入\n123445 310 10 110 5 150 400 2\n\n样例输出\n110\n\n\n\n代码如下：\n123456789101112131415161718192021222324252627282930313233343536373839404142// 1维分组背包#include&lt;iostream&gt;using namespace std;const int N = 1e3 + 10;int dp[N];int n, V;int v[N][N], w[N][N], cnt[N];// cnt[]存每个组的物品数int main(){    ios::sync_with_stdio(false);    cin.tie(0);    cout.tie(0);    \tcin &gt;&gt; V &gt;&gt; n;\tint gm = 0;//存储最大组数    int v1, w1, j;\tfor (int i = 1; i &lt;= n; i ++ )\t{\t\tcin &gt;&gt; v1 &gt;&gt; w1 &gt;&gt; j;\t\tv[j][++ cnt[j]] = v1;\t\tw[j][cnt[j]] = w1;\t\tgm = max(gm, j);\t}    n = gm;    \t//开始动态规划\tfor (int i = 1; i &lt;= n; i ++ )\t\tfor (int j = V; j &gt;= 0; j -- )\t\t\tfor (int k = 0; k &lt;= cnt[i]; k ++ ) // 判断要选该组的哪件物品\t\t\t\tif(v[i][k] &lt;= j)\t\t\t\t\tdp[j] = max(dp[j], dp[j - v[i][k]] + w[i][k]);\tcout &lt;&lt; dp[V] &lt;&lt; endl;\treturn 0;}\n\n\n\n\n\n结语以上便是背包问题最基础的类模型，实际上的题目可能会结合上其他算法状态压缩、贪心、树形\n又或是进行变式求方案数多目标\n篇幅有限，笔者就不多赘述，相信凭借各位的聪明才智，一定可以轻松应付​(ง •_•)ง\n\n\n如果文中有任何错误之处，欢迎大家在评论区批评指正！🙏\n\n","slug":"动态规划-背包问题","date":"2024-09-26T05:12:09.000Z","categories_index":"算法","tags_index":"动态规划,背包问题","author_index":"Jerry"},{"id":"c3878449dce899402d13b06cc735de00","title":"博弈论--NIM游戏","content":"引入先介绍几个概念\n1.公平组合游戏ICG：\n两名玩家交替行动\n在任意时刻，可执行的行动与玩家本身无关（游戏公平性）\n不能行动的玩家输\n\n2.有向图游戏\n给定一个有向无环图，具有唯一的起点，玩家交替的把棋子沿有向边进行移动，每次移动一步，无法移动者输\n任何ICG均可化为有向图游戏\n\n3.先手必胜与先手必败\n在双方均完全理性的情况下，先手不必胜则必败，先手不必败则必胜\n\nNIM游戏：1.介绍NIM 游戏是一种经典的组合博弈，两名玩家轮流从若干堆石子中选择一堆，并从中取走任意数量的石子。无法继续操作的玩家判负。\n2.结论对堆石子\n先手必胜态：\n先手必败态：\n3.证明：由数学归纳，从特殊推向一般\n不能操作时，每堆都是，\n\n当，任意一步操作之后\n反证：对任意一步操作使\n若，\n设\n则\n则，但是，矛盾！！得证\n\n当，一定存在一步操作之后\n证明：设，设的最高位在第位\n则中必定存在至少的第位也为，且\n（若第位均为，则所有异或之后得到的第位也只能是，不合题意）\n所以可以从中拿走个石子（上一步证明了此步的合法性）\n故，得证\n\n所以在双方绝对理性的情况下，某一方拿完之后达到了异或值为的情况后，会一直握住这个状态，\n保证自己必胜。\n更详细的思路构造过程及证明请看编程之美_1.11 NIM（1）一排石头的游戏在线阅读\nSG函数1.Mex运算：设表示一个非负整数集合，定义为求出不属于集合的最小非负整数的运算，\n即：且\n2.SG函数将游戏的所有状态及其转换关系抽象成一张有向无环图\n定义终点，\n示例：\n\n\n图中模拟一堆个数为的石子的状态转移图，每次只能拿个或个石子，蓝色字为石子数，红色字为 \n对应状态的值\n \n由图：任何一个非状态都可以到，任何一个状态都到不了\n则先手拿完后对手总有办法后手让先手必败\n先手总有办法拿完使对手怎么拿都使先手必胜\n\n性质：\n对一个含多个图的游戏，取每个图起点的值\n则必胜，当\n必败，当\n3.证明：类似一般游戏\n，没有必胜的起点，则，必败\n\n存在，则我先手一定可以走一步到达，此时，对方 \n先手必败，即我方必胜\n\n：不全为的情况\n不管怎么走，，必将落入对方先手必胜局面，即我方必败\n分类NIM博弈的内容大致就这么多啦~\n来几道题目练练手,看看题目中是怎么变形的~\n基础变形\n洛谷 P1247 取火柴游戏\n洛谷 P7589 黑白棋        关键在翻译题目，本质就是简单的nim游戏\nP5675 取石子游戏         背包DP + 阶梯nim，代码不难理解，关键是想明白思路，考思维\n阶梯 Nim\nP3480 KAM-Pebbles    差分数组的阶梯nim\nP2575 高手过招\n\n\n如果文中有任何错误之处，欢迎大家在评论区批评指正！🙏\n\n","slug":"博弈论-NIM游戏","date":"2024-09-26T05:11:45.000Z","categories_index":"算法","tags_index":"博弈论,NIM游戏,SG函数","author_index":"Jerry"},{"id":"9fc7aaa29955e8777b63cdc5e2f3c111","title":"快速幂","content":"快速幂快速计算\n\n朴素计算 \n\n显然当过大时太慢了\n快速幂计算 思路\n即二进制\n所以\n\n\n\n\n而每次往后只需把平方一下就行\n代码123456789101112131415// 快速幂int qmi(int a, int k, int p){\t// 计算 a^k % p    int res = 1;    while (k)    {        // 判断ci是否为1,如果是就需要乘否则跳过        if (k &amp; 1) res = (long long)(res * a) % p; // 取模的乘法运算        k &gt;&gt;= 1;        a = (long long)(a * a) % p;    }        return res;}\n\n\n\n应用求逆元\n逆元 除法的取模运算\n定义：若互质满足\n则称逆元记号，不是\n\n思路如下\n同乘约\n由费马定理\n\n结语由此，我们便有了乘除法的取模运算法则\n\n\n","slug":"快速幂","date":"2024-09-26T05:11:31.000Z","categories_index":"","tags_index":"快速幂,数论","author_index":"Jerry"},{"id":"40241814551b223b651e15683e69d116","title":"数学--约数","content":"约数1.求约数试除法求所有约数\n枚举\n对存\n代码：\n123456789101112vector&lt;int&gt; get_divisors(int x){    vector&lt;int&gt; res;    for (int i = 1; i &lt;= x / i; i ++ )        if (x % i == 0)        {            res.push_back(i);            if (i != x / i) res.push_back(x / i);        }    sort(res.begin(), res.end());    return res;}\n\n细节：存再排序比较方便\n2.约数个数 + 约数之和对任意自然数均可分解质因数为若干质数之积，即\n\n更新ing……\n","slug":"数学-约数","date":"2024-09-26T05:10:57.000Z","categories_index":"算法","tags_index":"数论,约数","author_index":"Jerry"},{"id":"6390ac85391cd221383c57783115e1e4","title":"数学--质数","content":"质数\n\n\n\n\n\n\n\n\n&gt;1 只包含1和本身两个约数\n1.判断质数试除法，只需枚举即可\n代码：\n12345678bool is_prime(int n){    if (n &lt; 2) return false;    for (int i = 2; i &lt;= n / i; i ++ )        if (x % i == 0)            return false;    return true;}\n\n细节\n①不推荐写要调用函数，太慢\n②不推荐写当太大时有可能溢出\n2.分解质因数最多只含一个的质因子，还是试除法，遇到约数就约掉\n如果约掉了所有的质因子之后仍，则约剩下的数必是质因子，单独处理即可\n代码：\n12345678910111213void divide(int n){    for (int i = 2; i &lt;= n / i; i ++ )        if (n % i == 0)        {            // 约掉所有因子，易证从小到大约掉的因子必是质因子            int s = 0;            while (x % i == 0) x /= i, s ++ ;            cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; s &lt;&lt; endl; // 输出质因子及其个数        }    if (x &gt; 1) cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; 1 &lt;&lt; endl; // 单独处理最后一个因子    cout &lt;&lt; endl;}\n\n\n\n3.筛质数给一个范围筛掉范围内所有的质数\n朴素筛法思路：\n从枚举，依次筛掉倍数，倍数，倍数，\n埃氏筛法优化：\n只筛掉质数的倍数，如在中枚举到，已经在的时候就被筛了，就跳过不再筛的倍数了\n显然，如果枚举到某个数，在前面没被筛掉则必是质数 \n缺点：仍旧还是有些数被重复筛了，如会被和同时筛掉，效率仍待提高\n线性筛法优化：每个数只会被自己最小质因子筛掉，如在上面只会被筛掉\n伪代码：\n①一定是最小质因子一定是最小质因子\n②一定小于的所有质因子也一定是最小质因子\n③按照此逻辑来决定一个数一个数筛\n代码：\n123456789101112131415int primes[N], cnt;     // primes[]存储所有素数bool st[N];         // st[x]存储x是否被筛掉void get_primes(int n){    for (int i = 2; i &lt;= n; i ++ )    {        if (!st[i]) primes[cnt ++ ] = i;        for (int j = 0; primes[j] &lt;= n / i; j ++ )        {            st[primes[j] * i] = true;            if (i % primes[j] == 0) break;        }    }}\n\n\n\n\n如果文中有任何错误之处，欢迎大家在评论区批评指正！🙏\n\n","slug":"数学-质数","date":"2024-09-26T05:10:48.000Z","categories_index":"算法","tags_index":"数论,质数","author_index":"Jerry"},{"id":"23e5ccb93b471aba058840eff980504f","title":"图论--最短路","content":"最短路先贴张总体图：\n\n\n1.单源最短路(1)边权均为正数①朴素Dijkstra算法思路：\n\ndist[i]存到起点的最短距离（在执行过程更新），st[i]存是否已确定最短距离\n集合S已经确定最短距离的点集（实际上就是st[]为true的点）\n初始化所有点到起点距离均为无穷大，将起点到起点距离设置为0\n找当前所有未定最短距的点中的最近点t，用t更新其他点最短距离，并将t丢进集合S里\n迭代n次，即可确定所有点最短路\n\n步骤：\n下面用一个具体的例子来辅助解释这个过程\n\n初始化\n\n\n\n\n起点到起点的距离为，即\n\n\n\n\n遍历数组，找到一个节点，这个节点是：没有确定最短路的节点中距离起点最近的点。\n假设该节点编号为，此时就找到了起点到该节点的最短距离，置为\n\n\n\n\n\n遍历所有可以到达的节点，如果大于加上的距离\n即（为的距离），则更新\n\n\n\n\n\n\n\n一直重复上面的步骤直至所有点的最短路均被确定\n\n\n\n\n此时起点到所有点的最短路均被确定\n\n\n\n\n\n注意事项：\n复杂度：遍历次遍历个点找最近点\n稠密图，邻接矩阵存有向图\n当前情况需要每个点要求第一次出队的时候就已经确定最短路，所以要求图内不能有负权边\n（否则第一次出队可能不是最短路，则当前算法失效）\n伪代码：\n12345678int dist[n],state[n];dist[1] = 0, state[1] = 1;for(i:1 ~ n){    t &lt;- 没有确定最短路径的节点中距离源点最近的点;    state[t] = 1;    更新 dist;}\n\n\n\n代码模板：\n123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;int n;\t\t  // 点数int d[N][N];  // 邻接矩阵存有向图int dist[N];  // 存储1号点到每个点的最短距离bool st[N];   // 存储每个点的最短路是否已经确定// 求1号点到n号点的最短路，如果不存在则返回-1int dijkstra(){    memset(dist, 0x3f, sizeof dist);    dist[1] = 0;    for (int i = 0; i &lt; n - 1; i ++ )    {        int t = -1;     // 在还未确定最短路的点中，寻找距离最小的点        for (int j = 1; j &lt;= n; j ++ )            if (!st[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j]))                t = j;        // 用t更新其他点的距离        for (int j = 1; j &lt;= n; j ++ )            dist[j] = min(dist[j], dist[t] + d[t][j]);        st[t] = true;    }    if (dist[n] == 0x3f3f3f3f) return -1;    return dist[n];}\n\n\n\n②堆优化版Dijkstra算法思路：\n\n容易发现在朴素Dijkstra算法中，通过枚举来找最近点的操作值得优化，这里采用小根堆来存所有点当前离起点的最短路，堆顶即为最近点，这步操作的复杂度仅为 \n其余仍与朴素Dijkstra一样\n\n注意事项： \n复杂度：稀疏图，邻接表存有向图\n代码模板：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;typedef pair&lt;int, int&gt; PII;int n;      \t\t\t\t\t\t// 点的数量int h[N], w[N], e[N], ne[N], idx;   // 邻接表存储所有边int dist[N];        \t\t\t\t// 存储所有点到1号点的距离bool st[N];    \t\t\t\t\t \t// 存储每个点的最短距离是否已确定// 初始化邻接表void init(){    memset(h, -1, sizeof h);}// 连接有向边a→bvoid add(int a, int b, int c){    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;}// 求1号点到n号点的最短距离，如果不存在，则返回-1int dijkstra(){    memset(dist, 0x3f, sizeof dist); // 初始化距离为无穷大    dist[1] = 0;    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap; // 小根堆    heap.push({0, 1});      // first存储距离，second存储节点编号    while (heap.size())    {        auto t = heap.top(); // 取出最近点        heap.pop();        int ver = t.second, distance = t.first;        if (st[ver]) continue;        st[ver] = true;        for (int i = h[ver]; i != -1; i = ne[i])        {            int j = e[i];            if (dist[j] &gt; distance + w[i])            {                dist[j] = distance + w[i];                heap.push({dist[j], j});            }        }    }    if (dist[n] == 0x3f3f3f3f) return -1;    return dist[n];}\n\n\n\n！思考：为何Dijkstra只对非负权边有效，能举出例子证明吗？\n(2)存在负权边①Bellman-Ford算法思路：\n注意事项：\n\n复杂度\n\n代码模板：\n123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;int n, m;       // n表示点数，m表示边数int dist[N];        // dist[x]存储1到x的最短路距离struct Edge     // 边，a表示出点，b表示入点，w表示边的权重{    int a, b, w;}edges[M];// 求1到n的最短路距离，如果无法从1走到n，则返回-1。int bellman_ford(){    memset(dist, 0x3f, sizeof dist);    dist[1] = 0;    // 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。    for (int i = 0; i &lt; n; i ++ )    {        for (int j = 0; j &lt; m; j ++ )        {            int a = edges[j].a, b = edges[j].b, w = edges[j].w;            if (dist[b] &gt; dist[a] + w)                dist[b] = dist[a] + w;        }    }    if (dist[n] &gt; 0x3f3f3f3f / 2) return -1;    return dist[n];}\n\n\n\n②SPFA算法思路：\n注意事项：\n\n复杂度一般，最多\n代码短，非负权边的情况一般也能用，但是容易被卡，建议还是在存在负权边时才用\n要求一定不含负环！！！！！\n\n代码模板：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;int n;      \t\t\t\t\t\t\t// 总点数int h[N], w[N], e[N], ne[N], idx;       // 邻接表存储所有边int dist[N];        \t\t\t\t\t// 存储每个点到1号点的最短距离bool st[N];     \t\t\t\t\t\t// 存储每个点是否在队列中void init(){    memset(h, -1, sizeof h);}// 连接a→b的有向边void add(int a,int b, int c){    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;}// 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1int spfa(){    memset(dist, 0x3f, sizeof dist);    dist[1] = 0;    queue&lt;int&gt; q;    q.push(1);    st[1] = true;    while (q.size())    {        auto t = q.front();        q.pop();        st[t] = false;        for (int i = h[t]; i != -1; i = ne[i])        {            int j = e[i];            if (dist[j] &gt; dist[t] + w[i])            {                dist[j] = dist[t] + w[i];                if (!st[j])     // 如果队列中已存在j，则不需要将j重复插入                {                    q.push(j);                    st[j] = true;                }            }        }    }    if (dist[n] == 0x3f3f3f3f) return -1;    return dist[n];}\n\n\n\n2.多源最短路Floyd算法思路：注意事项：代码：1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int INF = 0x3f3f3f3f;int d[N][N]; // 邻接矩阵存距离// 初始化void init(){\tfor (int i = 1; i &lt;= n; i ++ )        for (int j = 1; j &lt;= n; j ++ )            if (i == j) d[i][j] = 0;            else d[i][j] = INF;}// 算法结束后，d[a][b]表示a到b的最短距离void floyd(){    for (int k = 1; k &lt;= n; k ++ )        for (int i = 1; i &lt;= n; i ++ )            for (int j = 1; j &lt;= n; j ++ )                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);}\n\n","slug":"图论-最短路","date":"2024-09-26T05:09:40.000Z","categories_index":"算法","tags_index":"最短路,图论,Dijkstra,SPFA,Bellman-Ford,Floyd","author_index":"Jerry"},{"id":"708fa6adfa46361c793158b58a61f772","title":"bfs","content":"宽度优先搜索\n待更新…………\n模型\nFlood Fill\n多源bfs\n双端队列bfs\n双向广搜\nA*\n","slug":"bfs","date":"2024-09-26T05:09:28.000Z","categories_index":"","tags_index":"","author_index":"Jerry"},{"id":"c0864a7ed82c2e6dd4eb8a34dacd4941","title":"dfs","content":"深度优先搜索\n想了一下dfs还是挺杂的，近期可能暂时整理不完啦，丢几个关键词，后续计划更新\n判断连通性\n剪枝\n\n可行性\n最优性\n估测性-预测未来\n\n迭代加深—早回头\n双向DFS\nIDA*\n","slug":"dfs","date":"2024-09-26T05:09:23.000Z","categories_index":"","tags_index":"","author_index":"Jerry"},{"id":"f897c3d44f1ea027302ceab6694fc628","title":"单调队列与单调栈","content":"","slug":"单调队列与单调栈","date":"2024-09-26T05:09:03.000Z","categories_index":"","tags_index":"","author_index":"Jerry"},{"id":"c18469ab20e7b093d36b4a61728d07eb","title":"并查集","content":"并查集（Union-Find）概述并查集是一种高效的数据结构，以多棵树的形式存储，每棵树有一个被打上标记的根节点\n主要用途：\n\n合并两个集合\n查询元素所属的集合\n\n常见题型：\n\n朴素并查集\n带权并查集\n维护size并查集\n\n数据结构并查集通常使用三个数组实现：\n\np[] (parent)数组：记录每个元素的父节点。\nd[] (distanse)数组：记录每个元素到父节点距离\nsize[]数组：记录每个并查集的大小\n\nps:虽然并查集在逻辑结构上是一棵棵在同一集合的树，但是存储结构仍可以用普通的数组实现\n操作1.建立初始化并查集\n并查集根节点root:的标记方式p[root] = root\n表示根节点的父节点就是自己\n123456void init()&#123;\t// 一开始每个节点各自为营\tfor (int i = 1; i &lt;= n; i ++ )\t\tp[i] = i;&#125; \n\n2.查找查找元素 x 所在集合的根节点：\n这里有个优化，利用递归在查找的时候就直接把每个节点的父节点压缩向了祖宗节点，此时距离d也更新为了到父节点(祖宗节点)的距离\n1234567891011int find(int x)&#123;    if (p[x] != x) p[x] = find(p[x]);    // p[x]效果为找x的祖宗节点    // 这里调用p[x] = find(p[x])直接让x的父节点指向了p[x]的祖宗节点    // 经过层层递归会最终指向整棵树的根节点    int root = find(p[x]);     // 先要存root是因为只有先跑find()才能让d[p[x]]变为p[x]到祖宗节点的距离    d[x] += d[p[x]];    return root;&#125;\n\n3.合并合并两棵树：\n12345678910111213void merge(int x, int y)&#123;\t// 找出两棵树的根节点\tint px = find(x), py = find(y);\t\t// 根节点不同才需要合并\tif (px != py)     &#123;\t\tp[px] = py;        size[py] += size[px];        // 可能还需要对d[px]进行操作,具体情形依题目而定\t&#125;&#125;\n\n至此，并查集的基本操作均已介绍完毕，操作简洁作用大，用处这么大的数据结构上哪里找呀~\n来几道例题尝试尝试~\n例题朴素并查集\n洛谷 P3367 【模板】并查集\n\n\n维护size的并查集\n洛谷P1455 搭配购买\n\n\n维护到祖宗节点距离的并查集(带权并查集)\n 洛谷P1196 银河英雄传说\n 洛谷P2024食物链 \n\n\n如果文中有任何错误之处，欢迎大家在评论区批评指正！🙏\n\n\n\n","slug":"并查集","date":"2024-09-26T05:08:52.000Z","categories_index":"数据结构","tags_index":"并查集","author_index":"Jerry"},{"id":"a448dfd8ebb4408d1633f0dff8411f1c","title":"线段树","content":"线段树（Segment Tree）概述线段树是一种高效的数据结构，用于解决区间查询和更新问题。它能够在 (O(\\log n)) 时间复杂度内完成以下操作：\n\n查询区间和\n更新区间元素\n\n线段树特别适用于需要频繁处理区间查询和动态更新的场景。\n数据结构线段树通常使用完全二叉树的形式存储，节点表示数组的不同区间。假设原数组为 A，线段树为 ST，则每个节点 ST[node] 表示数组 A 的某个区间的值。\n操作1. 建树操作构建线段树的过程如下：\ndef build(A, ST, node, start, end):\n    if start == end:\n        ST[node] = A[start]  # 叶子节点\n    else:\n        mid = (start + end) // 2\n        build(A, ST, 2 * node + 1, start, mid)  # 构建左子树\n        build(A, ST, 2 * node + 2, mid + 1, end)  # 构建右子树\n        ST[node] = ST[2 * node + 1] + ST[2 * node + 2]  # 计算节点值\n","slug":"线段树","date":"2024-09-26T05:05:40.000Z","categories_index":"数据结构","tags_index":"线段树","author_index":"Jerry"},{"id":"7ff326fdf142ec1868a8e7b87c57157c","title":"基础数据结构","content":"链表链表是一种线性数据结构，由一系列节点组成，每个节点包含数据部分和指向下一个节点的指针。链表的优点是插入和删除操作效率高，但随机访问的效率较低。根据节点的连接方式，链表可分为以下几种类型：\n\n单向链表：每个节点指向下一个节点。\n双向链表：每个节点既指向下一个节点，又指向前一个节点。\n循环链表：最后一个节点指向头节点，形成一个环。\n\n栈栈是一种后进先出（LIFO）的数据结构，插入和删除操作都发生在同一端，称为栈顶。常用的栈操作包括：\n\npush：将元素压入栈顶。\npop：从栈顶弹出元素。\npeek：查看栈顶元素但不弹出。\n\n栈在函数调用管理、表达式求值等场景中广泛应用。\n队列队列是一种先进先出（FIFO）的数据结构，插入操作发生在队尾，删除操作发生在队头。常用的队列操作包括：\n\nenqueue：将元素插入队尾。\ndequeue：从队头删除元素。\nfront：查看队头元素但不删除。\n\n队列常用于任务调度、打印任务管理等场景。\n堆堆是一种特殊的树形数据结构，满足堆性质：在最大堆中，父节点的值大于或等于其子节点的值；在最小堆中，父节点的值小于或等于其子节点的值。堆的主要特点包括：\n\n插入：将新元素添加到堆中后，进行上浮操作维护堆性质。\n删除：删除堆顶元素后，将最后一个元素移至堆顶，进行下沉操作维护堆性质。\n\n堆常用于实现优先队列和高效的排序算法（如堆排序）。\n","slug":"基础数据结构","date":"2024-09-26T05:01:20.000Z","categories_index":"数据结构","tags_index":"链表,栈,队列,堆","author_index":"Jerry"},{"id":"36ef81d64d1d0edc64820d5afd16a0b4","title":"树状数组","content":"树状数组（Fenwick Tree）概述树状数组是一种用于高效处理动态数组中前缀和查询的数据结构。它能够在 (O(\\log n)) 时间复杂度内完成以下操作：\n\n更新数组中的元素O(logn)\n查询数组前缀和O(logn)\n\n数组： O(1) 更新，O(n) 前缀和\n前缀和数组：  O(n) 更新，O(1) 前缀和\n如果问题同时要大量更新和求前缀和，上述两种数据结构均会寄掉\n树状数组则采取折中思路，把整体复杂度降低至O(logn)\n数据结构先放张整体结构图：\n\n\n\n\n核心思想：二进制\n对任意数x可将其二进制分解\n其中\n从而将区间(0, x]分为以下几个部分：\n长度\n长度\n长度\n长度\n容易发现，对于任意一段区间(L,R]\n区间长度为lowbit(x),区间左端点L = R - lowbit(R)\n则在上述规则下，只要确定右端点，左端点的信息也唯一确定\n\n树状数组用一个数组来存储序列的信息:\ntr[x]：存储序列在[x - lowbit(x) + 1, x]之间的数的片段和\n则按照前面的区间划分规则\n看到公式的第三行，很容易想到可以用递归来实现，只需每层往下不断-lowbit(t)就行\nx最多只有logx位1，所以树状数组求前缀和的操作复杂度是O(logn)\n类似的，若要实现在原数组第x位上添加c均需添加c(可能这个结论不是那么明显，读者可自行思考其中的原理，后续笔者将补充上证明)\n当然这里不会无穷往后面加，我们只需用到1~n的数据，当加到超过n就可以停了，故整该操作的复杂度仍旧为O(logn)（分析同求和\n一个更容易理解的视频讲解\n操作1. lowbit运算复杂度：O(1)\n代码如下，大家可以自行找几个数验证一下\n12345int lowbit(int x){    // 取出x的最后一位1    return x &amp; -x;}\n\n\n\n2.添加复杂度：O(logn)\n123456int add(int x, int c){\t// 向第x位添加c,c可正可负\t// 对所有含第x位的树节点均加上c\tfor (int i = X; i &lt;= n; i += lowbit(i)) tr[i] += c;}\n\n\n\n3.前缀和复杂度：O(logn)\n1234567int sum(int x){\t// 对第1~x位求和\t// 计算当前数存的值,然后迭代求剩余节点的值\tif (!x) return 0;\treturn tr[x] + sum(x - lowbit(x));}\n\n\n\n\n\n例题洛谷 P10589 楼兰图腾\nPOJ 2182 迷路的奶牛 \nPOJ 3468  A Simple Problem with Integers \n题解待更新\n\n\n如果文中有任何错误之处，欢迎大家在评论区批评指正！🙏\n\n\n\n","slug":"树状数组","date":"2024-09-26T04:54:35.000Z","categories_index":"数据结构","tags_index":"树状数组,lowbit,前缀和","author_index":"Jerry"},{"id":"8038215b5c2b5aa82664c7d7c50d2cdc","title":"二分","content":"二分\n\n\n\n\n\n\n注意\n❗❗❗❗二分查找的前提是被查找的数据必须有二段性\n\n如何理解这句话呢？\n举个例子，在数组[1, 5 , 8, 9, 23, 25, 40]里找9\n我可以让check标准为&lt;=9，则转化为找数组中&lt;=9最大值\n对于9左边的数，均小于等于9,而对于9右边的数，均大于9\n目标答案的两边一边满足check一边不满足check，这便是二段性的含义\n绝大多数时候，二段性均不明显，需要通过自行定义check标准把二段性弄出来，需要积累一定的题量\n核心思想二分查找通过不断缩小查找范围，每次将范围缩小一半，最终定位目标元素的位置。\n算法思路\n初始化边界\n\n进入二分，check(mid)\n\n重复操作\n\n\n核心：不断折半折半查找的关键在于通过不断折半查找区间，可以大幅度减少查找次数，效率为 O(log n)\n代码：\n二分的模板不唯一，关键就是要判断好循环终止条件和划分好折半区间的边界，避免死循环\n这里放一个我一直在用的模板\n整数二分\n123456789101112131415161718192021// 模板1：check选左bool check(int x)&#123;\t// 定义check标准\tif (……) return false;\treturn true;&#125;int main()&#123;    int l = L, r = R; // 初始化边界    int mid;    while (l &lt; r)    &#123;        mid = l + r &gt;&gt; 1;        if (check(mid)) r = mid;        else l = mid + 1;    &#125;    cout &lt;&lt; l &lt;&lt; endl;&#125;\n\n123456789101112131415161718192021// 模板2: check选右bool check(int x)&#123;\t// 定义check标准\tif (……) return false;\treturn true;&#125;int main()&#123;    int l = L, r = R;    int mid;    while (l &lt; r)    &#123;        mid = l + r + 1 &gt;&gt; 1;        if (check(mid)) l = mid;        else r = mid - 1;    &#125;    cout &lt;&lt; l &lt;&lt; endl;&#125;\n\n\n\n小数二分\n12345678910111213141516171819bool check(double x)&#123;\t// 定义check标准\tif (……) return false;\treturn true;&#125;int main()&#123;\tconst double eps = 1e-6; // 设置精度\tdouble l = L, r = R;\tdouble mid;\twhile (r - l &gt; eps)    &#123;    \tmid = (l + r) / 2;    \tif (check(mid)) r = mid;    \telse l = mid;    &#125;&#125;\n\n\n\n模板题洛谷P1083 借教室\n洛谷P3743 小鸟的设备\n洛谷P9240 冶炼金属 \n\n\n 如果文中有任何错误之处，欢迎大家在评论区批评指正！  🙏\n\n","slug":"二分","date":"2024-09-26T02:50:13.000Z","categories_index":"算法","tags_index":"基础算法,二分","author_index":"Jerry"},{"id":"2a1893ca085cc0c5b7d1cdcd8c0b1c91","title":"排序","content":"1.快速排序对数组 q 在下标 l 到 r 的范围内进行升序排序。\n快速排序通过多次的比较和交换，在一趟排序之中确定好选择的基准应该在的位置。这个位置满足的条件是：\n\n它的左边的数都小于它。\n它的右边的数都大于它。\n\n之后对左右的区间进行递归排序，最后所有的数都位于它应该在的地方，排序完成。\n排序思路\n确定分界点 x ：\n\n选择 x 为 q[l]、q[r] 或 q[(l + r) / 2] 中的任意一个。\nps: x可以任取，一般取为q[ l + r &gt;&gt; 1]\n\n\n\n调整数组：\n\nq[l] 到 q[x-1] 中的元素都小于 x，\nq[x+1] 到 q[r] 中的元素都大于或等于 x。\n\n\n递归处理子区间：\n\n\n核心操作双指针：\n\n设置两个指针，i 和 j，分别指向当前区间的头和尾。\n两个指针向中间移动，遇到不满足条件的元素(需要交换)时停止。\n交换这两个指针指向的元素，然后继续移动指针，直到它们相遇。\n\n注意事项\n在判断条件时要确保准确，避免死循环→注意前面的最前面的return判断\n确定好每次递归的区间，确保排序的完整性。\n时间复杂度O(nlogn)\n\n\n 如果文中有任何错误之处，欢迎大家在评论区批评指正！  🙏\n\n\n代码：12345678910111213141516void quick_sort(int q[], int l, int r)&#123;\tif (l &gt;= r) return; // 排序完成,返回\tint x = q[l + r &gt;&gt; 1], i = l - 1, j = r + 1;\twhile (i &lt; j)    &#123;\t\t// 当两个指针未相遇时,一直移动直至需要交换    \tdo i ++; while(q[i] &lt; x);    \tdo j --; while(q[j] &gt; x);    \tif (i &lt; j) swap(q[i], q[j]); // 交换    \t    \t// 分治子区间    \tquick_sort(q, l, j);    \tquick_sort(q, j + 1, r);    &#125;&#125;\n\n直接理解可能还是有点抽象，也许你会觉得好像寻找分界点让左小又大能有一定的排序作用，但是get不到为什么这样一通操作能保证全体点都严格排好序，找到了张动态图给大家参考一下~\n\n2.归并排序对数组 q 在下标 l 到 r 的范围内进行升序排序。\n核心思想分治\n排序思路\n确定分界点mid：\n\nmid = (l + r) / 2，将数组分为两部分。\n\n\n递归排序：\n\n递归地对 q[l] ~ q[mid] 和 q[mid+1] ~ q[r] 两部分进行排序，此时两部分已各自有序→当前需要进行的操作仅为归并已经排好的两段区间\n\n\n合并：\n\n\n核心操作双指针：\n\n指针分别指向两部分的头部。\n比较两部分当前指针指向的元素，将较小的复制到一个新的数组中。\n当其中一部分复制完后，将另一部分剩余的元素全部复制到新数组。\n将合并后的新数组复制回原数组。\n\n注意事项\n递归时需要确保左右部分的区间划分正确。\n时间复杂度O(nlogn)\n\n代码：12345678910111213141516171819202122232425262728const int N = 1e6 + 10; // 根据具体题目定数量级int tmp[N]; // 用来临时存归并完的数组void merge_sort(int q[], int l, int r)&#123;\tif (l &gt;= r) return; // 排序完成,返回\t\tint mid = l + r &gt;&gt; 1;\t\t// 排序好子区间\tmerge_sort(q, l, mid), merge_sort(q, mid + 1, r);\t\t// 合并\tint i = l, j = mid + 1, k = 0;\tint tmp[N];\twhile (i &lt;= mid &amp;&amp; j &lt;= r)\t&#123;\t\tif (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];\t\telse tmp[k ++ ] = q[j ++ ];\t&#125;\t\twhile (i &lt;= mid) tmp[k ++ ] = q[i ++ ];\twhile (j &lt;= r) tmp[k ++ ] = q[j ++ ];\t\t// 把排完序的数组拷贝回去\tfor (i = l, k = 0; i &lt;= r;) q[i ++ ] = q[k ++ ];&#125;\n\n归并排序在大一的程设中也有出现喔，这里贴个图模拟一下排序的流程~\n\n排序模板题：洛谷 P1177 归并排序\n洛谷P1908 逆序对\n\n\n 如果文中有任何错误之处，欢迎大家在评论区批评指正！🙏\n\n","slug":"排序","date":"2024-09-26T02:05:17.000Z","categories_index":"算法","tags_index":"基础算法,快速排序,归并排序","author_index":"Jerry"},{"id":"b70cb6e2fe5cd3e70bacd823f6f633fc","title":"近期规划","content":"欢迎来到我的小天地！🎉嘿，欢迎来到我的小天地！这是一个属于技术与灵感碰撞的角落，无论你是路过还是驻足，都希望这儿能给你带来点什么有趣的东西。\n关于这个博客这个博客就像是我脑海里的“小宇宙”——技术、算法、科研，以及生活里的灵感火花。我想在这里和大家分享自己的探索，可能会有些前端、后端的技术总结，算法题目挑战的记录，项目笔记及日常随笔。\n你可以期待什么？未来这里会不断更新关于技术的思考、算法题的解题策略，也许还会时不时出现一些歌曲推荐 🎸 或者跑步训练随笔 🏃。你可以期待这里每一篇文章都带来一点灵感和乐趣！\n一起互动吧！如果你对某个技术话题感兴趣，或者也喜欢讨论算法问题，随时留言！我非常期待与你的互动。别害羞，我的评论区永远欢迎你！🙌\n\n好了，不多剧透了，先看文章吧！希望你每次来访都能有所收获，并愿意常来坐坐 😊。\n","slug":"近期规划","date":"2024-09-26T01:49:54.000Z","categories_index":"公告","tags_index":"","author_index":"Jerry"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post1$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server1$ hexo server\n\nMore info: Server\nGenerate static files1$ hexo generate\n\nMore info: Generating\nDeploy to remote sites1$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2024-09-25T08:52:32.921Z","categories_index":"博客","tags_index":"博客部署","author_index":"Jerry"}]