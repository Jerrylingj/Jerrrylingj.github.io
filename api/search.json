[{"id":"d0789a156a113e8f8fef603344b9162c","title":"html,css,js","content":"1.html1.1 文件结构html 文件以树的形式组织\n1.2 基本标签\n: \n根节点\n\n\n: \n\n规定文档相关的配置信息：标题、引用的文档样式、脚本\n\n设置 icon:\n\n\n\n\n: \n\n表示文档的内容，document.body 树形可以访问 body 元素脚本\n\n: \n定义文档标题，显示在浏览器标题栏上，只能包含文本，包含的任何标签的会被忽略\n\n\n\n\n\n: \n剩余的均用 meta 标签表示\n常见属性：\ncharset\nname\n\n\n\n1.3 注释123&lt;!-- this is a 注释--&gt;\n\n1.4 文本标签绝大部分标签本质都是一样的，只不过有些标签是根据大多数用户的需求进行了标准化\n\n: \n通用型流行内容容器，块状元素\n\n\n: \n行内元素\n\n\n\n比较：\n\n自带前后回车\n\n*不带回车*\n\n~:\n\n六级标题\n\n: \n\n文本的一段，块级元素，自带回车\n其实就是加了前后行间距，自动过滤空格和回车\n\n\n\n\n:\n\n预定义格式文本，不会过滤换行和空格\n'>'用&**gt**\n'用&**lt**\n空格用‘nbsp'\n\n\n:\n\n在文本生成一个换行，在写诗和写地址的时候有用\n\n\n: \n\n表示段落及元素之间主题转换（一个故事中场景的改变或一个章节主题的改变）→在可视化浏览器表现为水平线\n\n\n: \n\n区分普通文本的一系列文本，一般为斜体\n\n\n: \n\n加粗，替代方案是用 CSS font-weight 来创建粗体文字\n\n\n: \n\n表示一些被从文档中删除的文字内容，一般用于显示修改记录或者源代码差异的情况\n\n\n: \n\n与 del 相反，表示加入的内容\n\n\n\n1.5 图片\nsrc: \n路径/地址\n\n\nalt: \n对文本表述，非强制性，当图片无法正常显示时展示\n\n\n\n\n\nheight\n高度，单位是 CSS 像素\n\n\nwidth\n宽度，单位是 CSS 像素\n\n\n\n1.6 音频与视频\n\n\n\n\n嵌入音频，src 表示地址\n1234567891011&lt;!--自动播放--&gt;&lt;audio src=&quot;/audios/林俊杰 - 愿与愁.mp3&quot; autoplay&gt;&quot;/audios/愿与愁.mp3&quot;无法播放&lt;/audio&gt;&lt;!--手动播放--&gt;&lt;audio controls src=&quot;/audios/林俊杰 - 愿与愁.mp3&quot;&gt;&quot;/audios/愿与愁.mp3&quot;无法播放&lt;/audio&gt;&lt;!--一次存多个音源，前面不行就放后面的--&gt;&lt;audio controls&gt;        &lt;source src=&quot;/audios/林俊杰 - 愿与愁.mp3&quot; type=&quot;audio/mpeg&quot;&gt;&quot;/audios/愿与愁.mp3&quot;无法播放&lt;/source&gt;        &lt;source src=&quot;/audios/郭采洁 - 你在不在.mp3&quot; type=&quot;audio/mpeg&quot;&gt;&quot;/audios/你在不在.mp3&quot;无法播放&lt;/source&gt;&lt;/audio&gt;\n\n\n\n\n\n嵌入视频，src 表示地址\n\n&lt;!--自动播放--&gt;\n&lt;video src=\"/videos/video1.mp4\" autoplay&gt;&lt;/video&gt;\n\n&lt;!--手动播放--&gt;\n&lt;video controls src=\"/videos/video1.mp4\"&gt;&lt;/video&gt;\n\n&lt;!--一次存好几个视频--&gt;\n&lt;video controls&gt;\n        &lt;source src=\"/videos/video1.mp4\" type=\"video/mp4\"&gt;\"/videos/video1.mp4\"无法播放&lt;/source&gt;\n        &lt;source src=\"/videos/video2.mp4\" type=\"video/mp4\"&gt;\"/videos/video2.mp4\"无法播放&lt;/source&gt;\n&lt;/video&gt;\n1234567891011121314151617181920212223  - ![img](https://dw3q5i9n4hb.feishu.cn/space/api/box/stream/download/asynccode/?code=MmI0ZWQ5NjRjNjI3MGFkYzRlMzU1NDNlNDkxOTQwZmJfZFdaR24zdnVBYVBHcGxzaVRTUmlndWg5TGhLbnptNWNfVG9rZW46WFlpQWIxaGF1b29rbkV4NXo4cGNSNER1bkhkXzE3Mjc2ODc5MDc6MTcyNzY5MTUwN19WNA)  - ### 1.7 超链接&lt;a&gt;&lt;/a&gt;```HTML&lt;!--href+地址,标签中间放显示内容--&gt;&lt;a href=&quot;https://www.baidu.com&quot;&gt;百度&lt;/a&gt;&lt;!--相对路径--&gt;&lt;a href=&quot;/about.html&quot;&gt;About&lt;/a&gt;&lt;!--内嵌其他标签--&gt;&lt;!--内嵌图片，则整个图片就是一个超链接--&gt;&lt;!--target的作用是新开一个页面，没有target的话就是在原界面跳转--&gt;&lt;a href=&quot;\\about.html&quot; target=&quot;_blank&quot;&gt;        &lt;img height=&quot;800&quot; width=&quot;1650&quot; src=&quot;/images/picture2.jpg&quot; alt=&quot;about&quot;&gt;        关于&lt;/a&gt;\n\n\n\n\n\n\n\n1.8 表单\n\ntype=\"text\"：基础的单行文字\ntype=\"number\"：只能是数字\ntype=\"email\"：合法的邮箱地址\ntype=\"password\"：密码\ntype=\"radio\"：选择，同样 name 的 radio 只能选一个，要多选就得每个都命不同的名字\n\n\n\n\n12345678&lt;form&gt;        &lt;!--表头--&gt;        &lt;label for=&quot;username&quot;&gt;用户名&lt;/label&gt;        &lt;!--把输入数据绑定进来--&gt;        &lt;input type=&quot;text&quot; name=&quot;username&quot; id=&quot;username&quot;&gt;        &lt;!--加一个按钮--&gt;        &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt;&lt;/form&gt;\n\n\n\n+action=\"\"实现超链接功能\n→获取数据并跳转到下一个网页\n\n常见属性：\n\nname：名称\nid：唯一 id\nmaxlength：最大长度\nminlength：最小长度\nrequired：是否必填\nplaceholder：背景填充\n\n\n\n\n\n多行的框框，一个块区域\n\n\n+：选择框+选项\n\n\n默认选项： selected value\n1.9 列表\n无序\n\n- \n\n\n有序\n\n\n\n1.\n2.\n3.\n1.10 表格\n1.11 语义标签\n1.12 特殊符号\n2.CSS理解 html 与 css：\nhtml 是素颜，css 是化妆\n一个是底层，一个是装饰\n2.1 样式定义方式\n行内样式表：只对当前标签作用\n\n加多一个 style 属性，里面存储所有样式\n12345678&lt;!--设置宽度--&gt;&lt;!--html--&gt;&lt;img width=&quot;300&quot; src=&quot;&quot;&gt;&lt;!--css--&gt;&lt;img src=&quot;&quot; style=&quot;width: 300px;&quot;&gt;&lt;!--一些例子--&gt;&lt;div style=&quot;width: 100%;height: 100%;background-color: black;&quot;&gt;&lt;/div&gt;\n\n\n内部样式表：对同个页面多个元素产生影响\n\n单独写一个 style 标签，对某些标签的样式专门定义一个类\n\n对于同一种标签，用 class 来区别不同种样式，class 可以叠加\n\n\n外部样式表\n\n在一般的网站制作过程，有很多样式不可能在一个界面完成设计，需要写在额外的文件中，这时候在标签底下就要用方式引入进来以使用样式\n\n注：style 里面的注释只能用/* */\n2.2 选择器\n标签选择器\n\n123456&lt;!--选择所有div标签--&gt;div &#123;    width: 200px;    height: 200px;    backfground-color: gray;&#125;\n\n\nID 选择器\n\n对 id 属性选择\n123456&lt;!--选择ID为rect-1的标签--&gt;#rect-1 &#123;    width: 200px;    height: 200px;    background-color: red;&#125;\n\n\n类选择器\n\n对 class 属性选择\n123456&lt;!--选择所有rectangle类的标签--&gt;.rectangle &#123;    width: 200px;    height: 200px;    background-color: green; &#125;\n\n\n伪类选择器\n\n就是一个后缀，在前面几类的基础上加上一些特殊情况\n→如当鼠标悬停在这时、长按时……\n\n\n复合选择器\n\n\n\n通配符选择器\n\n\n\n伪元素选择器\n\n\n2.3 颜色\n2.4 文本\ntext-align\n\ncenter,left,right,justify \n\n定义行内元素（如文字）如何相对其块状父元素对齐，text-align 不控制块元素自己对齐，只控制他的行内内容的对齐\n\n子标签继承父标签的对齐方式\n\nline-height\n\n\n设置多行元素的空间量，如多行文本的间距，对于块级元素，指定元素行盒（line boxes）的最小高度，对于非替代的 inline 元素，它用于计算行盒（line box）的高度\n\n补充：长度单位\n\n\n\ntips：通过设置行高可以竖直居中\n\nletter-space：文本字符的间距\n\n\n\n\ntext-indent：块元素首行文本内容之前的缩进量\n\n\n\ntext-decoration：设置修饰线外观→在 MDN 上直接搜用法就行\ntext-decoration-line\ntext-decoration-style\ntext-decoration-thickness\n\n\n\n删除一条链接的任何修饰：\n\n\ntext-shadow：为文字添加阴影\n4 个参数：坐标（2）+阴影模糊半径+颜色\n模糊半径越大字体模糊\n坐标方向：\n\n\n\n\n\n2.5 字体\nfont-size：设置字体大小\nfont-weight：设置字体粗细程度\n\n\n\nfont-family：设置字体类型（楷体、黑体、宋体……）\n\n通过一个有先后顺序的，由字体名或者字体族名组成的列表来为选定的元素设置字体，属性之间用逗号隔开，浏览器会选择列表中第一个该计算机上有安装的字体，或者是通过@font-face 指定的可以直接下载的字体\n\nserif→带衬线字体      sans-serif→不带衬线字体\n\nmonospace→等宽字体\n\ncursive→草书字体\n\nfantasy→艺术字体\n\nfont-style：选择 font-family 底下的 italic 或 oblique 样式\n\n\n\n2.6 背景\nbackground-color：设置背景颜色\n\n置于最底层\n\nbackground-image：设置背景图像\n\n渐变色 linear-gradient（rgba（0， 0， 255， 0.5）， rgba（255， 255， 0， 0.5））\n\n多个图：中间用逗号隔开，越靠前的优先级越高\n\nbackground-image: url('./images/p1.ipg),url('./images/p2.jpg');\n/!-- p1优先级高于p2 --&gt;/\nbackgrount-size: 100px 200px, 200px 100px;\n12345678910111213141516171819202122232425262728293031323334353637- **background-size：**设置背景图片大小  - 50% 50% 横纵比例  - 200px 300px 大小- **background-repeat：**设置背景图像沿水平轴、竖直轴，两个轴重复，或者根本不重复- **background-position：**设置背景图片初始位置  - center     …px- **background-attachment：**设置背景图像的位置实在视口内固定或者随着区块滚动### 2.7 边框可以四条边独立设置样式- **border-style：**CSS 简写属性，用来设定元素所有边框的样式```HTML/* Apply to all four sides */border-style: dashed;/* horizontal | vertical */border-style: dotted solid;/* top | horizontal | bottom */border-style: hidden double dashed;/* top | right | bottom | left */border-style: none solid dotted dashed;/* Global values */border-style: inherit;border-style: initial;border-style: unset;\n\n\n\nborder-width：设置盒子模型的边框宽度\n\nborder-color：设置元素四个边框颜色的快捷属性\n\nborder-top-color\nborder-right-color\nborder-bottom-color\nborder-left-color\n\n\nborder-radius：设置矩形边框 4 个角的样式\n\n可以用来设置非常神奇的样式\n\n\nborder-collapse：设置相邻格子是否共享边框，设置在标签里\n\n\n2.8 元素展示格式\ndisplay: \nblock: \n独占一行\nwidth、height、margin（外边距）、padding（内边距）均可控制\nwidth 默认 100%\n\n\ninline: \n可以共占一行\nwidth 与 height 无效，水平方向的 margin 与 padding 有效，竖直方向的 margin 与 padding 无效\nwidth 默认为本身内容宽度\n\n\ninline-block: \n可以共占一行\nwidth、height、margin、padding 均可控制\nwidth 默认为本身内容宽度\n\n\n\n\nwhite-space：设置如何处理元素中的空白\nnowrap：不自动换行，多的直接溢出\npre：保留文本里的换行（原格式）？\n\n\ntext-overflow：设置文本溢出文本框部分的处理\nhidden：截断，不显示\nellipsis：超出部分用省略号代替\n\n\noverflow：设置内容显示是否有滚轮，分为 overflow-x，overflow-y\nhidden：不显示滚轮\nauto：自动设置滚轮\n\n\n\n2.9 内外边距边距：最小距离\n\nmargin：外边距\n直接设定 4 个值（上右下左）\n分别指明 4 个方向：\nmargin-top\nmargin-right\nmargin-bottom\nmargin-left  \n\n\n可取值：\nlength：固定值→xxpx\npercentage：相对于包含块的宽度的百分比\nauto：让浏览器自己选\n\n\n\n\n\npadding：内边距，用法和 padding 同\n元素最后大小=初始大小+内边距大小+边界大小\n​     width=content+padding+border\n\n\n\n\n2.10 盒子模型\nBox-sizing:\n设置元素总宽度和总高度，锁死\ncontent-box：默认值，设置 border，padding 均会增加元素的宽高\nborder-box：设置 border 和 padding 不会改变元素的宽高，而是挤占内容区域\n\n\n\n2.11 位置position：指定一个元素在文档中的定位方式\n\n2.11 浮动float: \nclear: \n2.12 flex 布局设置弹性项目如何增大或缩小以适应其弹性容器中可用的空间→更好布局各个模块\n\n主轴→    交叉轴↓    优先沿主轴方向，摆满后沿交叉轴方向延伸\n\n\n​            没有 flex\n​                 加了 flex\n\n可见 flex 可以改变内部元素排列方式\n当内部元素总宽度/长度大于当前元素时，会自动压缩\n\n\nflex-direction: \n\nrow：默认摆放方式，从左往右，从上往下\nrow-reverse：从右往左，从上往下\ncolumn：从上往下，从左往右\ncolumn：从下往上，从左往右\n\n\nflex-wrap:\n\n设置换行\nnowrap：默认，不换行\nwrap：换行，第一行在上\nwrap-reverse：换行，第一行在下\n\n\nflex-flow:\n\ndirection 和 wrap 一起设置\n\nflex-flow: row nowrap;\n&lt;!--code￼9--&gt;\n\n\n\nboolean：布尔\n\nobject：对象，类似于 C++里面的指针，例如：[1, 2, 3]，&#123;name: &quot;yxc&quot;, age: 18&#125;\n\nlet d = &#123;\n    name: 'jerry', // 前面的name可加可不加引号\n    age: 18,\n&#125;;\n\nconsole.log(d[\"name\"]); // map输出，必须加引号，同时这里允许动态变值\nconsole.log(d.name); // 点输出\n\nlet key = \"name\";\nconsole.log(d[key]); // 允许\nconsole.log(d.key); // 不允许\n\n// 字典允许动态添加属性\nd.school = \"sysu\"; // 添加school属性\n\n// 遍历字典\nfor (let key in d) &#123;\n    console.log(d[key]);\n&#125;\n&lt;!--code￼10--&gt;\n\n\n\n\n\n对象属性与函数的调用方式：\n\nperson.name、person.add_money(): \n简洁，但是关键字不可动态变化\n\n\nperson[&quot;name&quot;]、person[&quot;add_money&quot;]()\n繁琐，但是关键字可以动态变化\n\n\n\n3.6 数组\n特殊的对象，元素的变量类型是动态的\n\n如：\n\nlet a = ['lgj', 18, 175, 65]\n&lt;!--code￼11--&gt;\n\n可以通过这种访问方式动态赋值，甚至允许改变元素的类型\n\njs 里面没有下标越界概念，遇到没有定义的位置直接返回undefined，不会报错，甚至允许负下标的存在\n\n数组的长度：最大下标 + 1\n\n\n\n\n常用api\n\nlength：返回数组长度，注意是属性，不加()\n\npush()：添加元素\n\npop()：弹出元素\n\nsplice(a, b)：删除从 a 开始的 b 个元素\n\nsort()：默认从小到大排序，对整个数组排序\n\n自定义比较函数：array.sort(cmp)函数cmp输入两个比较的元素，返回一个实数\n\n例：\n\n// 给数组降序排序\nlet a = [5, 3, 2, 4, 1];\n\nlet main = function() &#123;\n    console.log(a);\n\n    a.sort(function(x, y) &#123;\n        x = parseInt(x), y = parseInt(y);\n        return y - x;\n    &#125;);\n\n    console.log(a);\n&#125;;\n\nexport &#123;\n    main\n&#125;;\n&lt;!--code￼12--&gt;\n\n\n\n\n\n\n\n可以不按照函数的定义格式传入参数，没有传入的参数默认为undefined，由于这样 js 里面应该是不存在函数重载的，太随意了吧\n\n函数返回值默认是undefined\n\n\n3.8 类与C++的class类似，但是不存在私有成员\n一般用驼峰命名法，即每个单词首字母大写\n\n定义\n\n123456789101112131415161718192021222324252627class Point &#123;    // 构造函数    constructor(x, y) &#123;        this.x = x;        this.y = y;    &#125;        // 类内函数不用加function关键字    init() &#123;        this.sum = this.x + this.y;    &#125;        toString() &#123;        return `($&#123;this.x&#125;, $&#123;this.y&#125;)`;    &#125;&#125;let main = function () &#123;    // 生成类对象    let p = new Point(3, 4);    console.log(p.x, p.y);    console.log(p.toString());&#125;export &#123;    main&#125;\n\n\n继承：用extends关键字\n\n123456789101112clsss ColorPoint extends Point &#123;    constructor(x, y, color) &#123;        // 必须先调用基类构造函数        super(x, y); // 这里的super是一个函数，特指基类的构造函数        this.color = color;    &#125;        // 派生类的成员函数会覆盖基类的成员函数    toString() &#123;        return `$&#123;this.color&#125; $&#123;super.toString()&#125;`; // 这里的super代表的是基类对象    &#125;&#125;  \n\n\n静态方法：加static关键字\n和C++类似，属于所有类对象的共有成员\n静态方法不会被类的实例继承，需要通过类名访问\n\n\n\n1234567891011121314151617181920212223class Point &#123;    // 构造函数    constructor(x, y) &#123;        this.x = x;        this.y = y;    &#125;        // 类内函数不用加function关键字    init() &#123;        this.sum = this.x + this.y;    &#125;        static print_class_name() &#123;        console.log(&quot;Point&quot;);    &#125;&#125;let main = function() &#123;    let p = new Point(3, 4);        console.log(p.print_class_name());     // 错误，静态对象不允许直接访问    console.log(Point.print_class_name()); // 正确，用类名调用静态对象   &#125;\n\n\n静态变量：\n和静态对象类似，和类本身绑定\n\n\n\n1234567891011121314151617class Point &#123;    // 构造函数    constructor(x, y) &#123;        this.x = x;        this.y = y;                Point.cnt ++ ;    &#125;        // 类内函数不用加function关键字    init() &#123;        this.sum = this.x + this.y;    &#125;&#125;// 静态变量定义：在类外Point.cnt = 0;\n\n3.9 事件js 代码一般通过事件触发，即通过事件实现对 CSS 和 html 的操控\n可以通过addEventListener函数为元素绑定事件的触发函数\n常见的触发函数有：\n\n鼠标\n\nclick：左键点击\ndblclick：左键双击\ncontextmenu：右键点击\nmousedown：鼠标按下，包括左键、滚轮、右键\nevent.button：0 表示左键，1 表示中键，2 表示右键\nevent.clientX：鼠标按下的位置\n其余的属性可以上 MDN 上搜索\n\n\nmouseup：鼠标弹起，包括左键、滚轮、右键\nevent.button：同上\n\n\n\n\n键盘\n\nkeydown：某个键是否被按住，事件会连续触发\nevent.code：返回被按住的键\nevent.altKey，event.ctrlKey，event.shiftKey分别表示alt，ctrl，shift是否被按住\n\n\nkeyup：某个键是否被释放\nevent：同上\n\n\nkeypress：紧跟在keydown事件后触发，只有按下字符键时触发\n\n\n\n\n\n表单\n\nfocus：聚焦某个元素\nblur：取消聚焦某个元素\nchange：某个元素的内容发生改变\n\n\n窗口\n\n需要作用到window元素上\nresize：窗口大小发生变化\nscroll：滚动指定的元素\nload：元素加载完成\n\n\n\n3.10 常用库3.10.1 jQuery让 js 更方便联系前端元素\n\n使用方式\n\n在元素中添加：\n\n按 jQuery 官网提示下载\n\n\n选择器\n\n$(selector) ，例如：\n\n$('div');\n$('.big-div');\n$('div &gt; p');\n&lt;!--code￼17--&gt;\n\n$(selector).on(event, func)解绑事件，例如：\n\n$('div').on('click', function(e) &#123;    \n    console.log(\"click div\");\n\n    $('div').off('click');\n&#125;);\n&lt;!--code￼18--&gt;\n\n在事件触发的函数中的return false等价于同时执行：\n\ne.stopPropagation()：阻止事件向上传递\ne.preventDefault()：阻止事件的默认行为\n\n\n\n\n元素的隐藏、展现\n\n$A.hide()：隐藏，参数表示消失时间\n$A.show()：展现，参数表示出现时间\n$A.fadeOut()：慢慢消失，参数表示消失时间\n$A.fadeIn()：慢慢出现，参数表示出现时间 \n\n\n元素的添加、删除\n\n$(&#39;&lt;div class=&quot;mydiv&quot;&gt;&lt;span&gt;Hello World&lt;/span&gt;&lt;/div&gt;&#39;)构造一个jQuery对象\n$A.append($B)：将$B添加到$A的末尾\n$A.prepend($B)：将$B添加到$A的前面\n$A.remove()：删除元素$A\n$A.empty()：清空元素$A的所有儿子\n\n\n对类的操作\n\n$A.addClass(class_name)：添加某个类\n$A.removeClass(class_name)：删除某个类\n$A.hasClass(class_name)：判断某个类是否存在\n\n\n对 CSS 操作\n\n$(&quot;div&quot;).css(&quot;background-color&quot;)：获取某个 CSS 的属性\n\n$(&quot;div&quot;).css(&quot;background-color&quot;,&quot;yellow&quot;)：设置某个 CSS 的属性\n\n同时设置多个 CSS 的属性：\n\n$('div').css(&#123;\n    width: \"200px\",\n    height: \"200px\",\n    \"background-color\": \"orange\",\n&#125;);\n&lt;!--code￼19--&gt;\n\n\n\nPOST 方法：\n\n\n12345678910$.ajax(&#123;    url: url,    type: &quot;POST&quot;,    data: &#123;    &#125;,    dataType: &quot;json&quot;,    success: function (resp) &#123;    &#125;,&#125;);\n\n3.10.2 setTimeout与setInterval返回number型数据，代表当前函数的唯一ID\n1setTimeout(func, delay)`：`delay`毫秒之后执行函数`func()\n\nclearTimeout()：关闭定时器，如：\n12345let timeout_id = setTimeout(() =&gt; &#123;    console.log(&quot;Hello World!&quot;);&#125;, 2000);    // 2秒之后输出&quot;Hello World!&quot;clearTimeout(timeout_id);     // 清除定时器\n\nsetInterval(func, delay)：每隔delay毫秒执行func()，第一次在第delay毫秒执行\nclearInterval()：关闭周期执行的函数，如：\n12345let interval_id = setInterval(() =&gt; &#123;    console.log(&quot;Hello World!&quot;);&#125;, 2000);    // 每隔2秒输出一次&quot;Hello World!&quot;clearInterval(interval_id);    // 清除周期执行的函数\n\n3.10.3 requestAnimationFramerequestAnimationFrame(func):\n在下次浏览器刷新(重新渲染之前)执行一次，通胀会用递归写法使其每秒执行60次func函数\n1234567let step = (timestamp) =&gt; &#123;  // 每帧将div的宽度增加1像素    let div = document.querySelector(&#x27;div&#x27;);    div.style.width = div.clientWidth + 1 + &#x27;px&#x27;;    requestAnimationFrame(step);&#125;;requestAnimationFrame(step);\n\n与setTimeout和setInterval的区别：\n\nrequestAnimationFrame渲染动画的效果更好，性能更佳。\n\n该函数可以保证每两次调用之间的时间间隔相同，但setTimeout与setInterval不能保证这点。setTmeout两次调用之间的间隔包含回调函数的执行时间；setInterval只能保证按固定时间间隔将回调函数压入栈中，但具体的执行时间间隔仍然受回调函数的执行时间影响。\nsetTimeout：\n\nsetInterval:\n\n\n当页面在后台时，因为页面不再渲染，因此requestAnimationFrame不再执行。但setTimeout与setInterval函数会继续执行。\n\ncancelAnimationFrame：停止requestAnimationFrame\n\n\n3.10.4 Map与Set\nMap：保存键值对,不能排序\n\n用for...of或者forEach可以按插入顺序遍历\n\n// for...of\nfor (let [key, value] of map) &#123;\n    console.log(key, value);\n&#125;\n\n// forEach\nmap.forEach(function(value, key) &#123;\n    console.log(key, value);\n&#125;) \n&lt;!--code￼25--&gt;\n\n\n\n\n\n3.10.7 日期返回值为整数的API，数值为1970-1-1 00:00:00 UTC（世界标准时间）到某个时刻所经过的毫秒数：\n\nDate.now()：返回现在时刻。\nDate.parse(&quot;2022-04-15T15:30:00.000+08:00&quot;)：返回北京时间2022年4月15日 15:30:00的时刻。\n\n与Date对象的实例相关的API：\n\nnew Date()：返回现在时刻。\nnew Date(&quot;2022-04-15T15:30:00.000+08:00&quot;)：返回北京时间2022年4月15日 15:30:00的时刻。\n两个Date对象实例的差值为毫秒数\ngetDay()：返回星期，0表示星期日，1-6表示星期一至星期六\ngetDate()：返回日，数值为1-31\ngetMonth()：返回月，数值为0-11\ngetFullYear()：返回年份\ngetHours()：返回小时\ngetMinutes()：返回分钟\ngetSeconds()：返回秒\ngetMilliseconds()：返回毫秒\n\n3.10.8 WebSocket与服务器建立全双工连接。\n常用API：\n\nnew WebSocket(&#39;ws://``localhost:8080``&#39;);：建立ws连接。\nsend()：向服务器端发送一个字符串。一般用JSON将传入的对象序列化为字符串。\nonopen：类似于onclick，当连接建立时触发。\nonmessage：当从服务器端接收到消息时触发。\nclose()：关闭连接。\nonclose：当连接关闭后触发。\n\n4.KOF优化记录：\n\n音频加载过慢\n\nGPT建议如下：\n\n\n\n\n\n\n","slug":"html-css-js","date":"2024-09-30T09:19:16.000Z","categories_index":"","tags_index":"","author_index":"Jerry"},{"id":"d6ffd179ab68b0daa56addeeaeb71166","title":"GPT获取sso信息出错","content":"尝试登陆GPT账号发现报错rt\n\n\n解决\n在网址的“auth”中加个0，改成https://auth0.openai.com//authorize?client这种形式再登录。\n\n\n正常登录\n","slug":"GPT获取sso信息出错","date":"2024-09-30T08:43:11.000Z","categories_index":"","tags_index":"GPT","author_index":"Jerry"},{"id":"bbe13304b560081099040d9e49fec292","title":"初级实训作业1-贪吃蛇","content":"\n\n\n\n\n\n\n\n\nQt实现，为避免雷同，展示大致的思路及部分效果图~\n其实之前已经写过一个贪吃蛇小游戏网站了，可惜当时重心放在后端的匹配系统和贪吃蛇bot的代码运行上，前端做的稍微简陋了一点\n这次恰好利用Qt，把整体游戏界面做的更丰满一些o(￣▽￣)ブ\n1.安装Qt参考教程\n2.创建项目\n\n\n\n\n\n\n构建系统—qmake\nDetails—Base class—QWidget\n\n\n\n\n新项目创建完毕\n\n\n运行效果—白框框\n3.整体设计蛇身 + 地图 + 道具掉落（种类多设计一点） +生命值 + 计分板 + 难度调节器（调节速度）\n设计：初始设定：积分 0\n道具：\n①food：长度+1，积分+10\n②wall：障碍物 碰到停止\n③咬到自己：死\n基本流程：①调节难度，开始游戏\n②读取键盘输入\n②处理方向更新\n③处理蛇身更新\n④处理道具更新\n⑤判断是否死亡\n⑥全体布局确定，渲染地图\n最初版效果图如下：\n\n\n4.Code(1)基本API待更新……\n","slug":"初级实训大作业1-贪吃蛇","date":"2024-09-29T15:18:32.000Z","categories_index":"小游戏","tags_index":"Qt","author_index":"Jerry"},{"id":"e9c911dbfeb3b82e631b7a70a15f2cf2","title":"动态规划--区间DP","content":"","slug":"动态规划-区间DP","date":"2024-09-26T05:12:32.000Z","categories_index":"","tags_index":"","author_index":"Jerry"},{"id":"62555a6f14b066c1f526e128e3c72f4d","title":"动态规划--线性DP","content":"","slug":"动态规划-线性DP","date":"2024-09-26T05:12:20.000Z","categories_index":"算法","tags_index":"动态规划,线性DP","author_index":"Jerry"},{"id":"398687178e2ec3c1a9498d5422c75757","title":"动态规划--背包问题","content":"🎮 背包问题欢迎来到 动态规划的冒险世界！在这趟旅途中，你将化身为一位勇敢的冒险者，面临一个经典而深邃的挑战：如何在有限的资源下获得最大的收益。每一关都充满了挑战，但只要你步步为营，掌握算法精髓，最终你会成为背包问题的 算法大师。准备好了吗？Let’s Go!\n\n前言背包问题是动态规划最经典的问题之一，在这里，我们初步学会如何使用动态规划解决问题\n绝大部分情况下，动态规划步骤如下：\n状态表示：集合描述\n状态计算：划分集合，把当前状态转化为子集状态（注意不重不漏）进而写出状态转移方程\n接下来，让我们到题目中理解这两步的含义吧！\n分类1.01背包\n种物品，体积背包\n物品体积，价值（最多只能用一次）​\n\n洛谷P1048 采药\n洛谷P1060 开心的金明\n2.完全背包\n种物品，体积背包\n物品体积，价值（无限用）\n\n洛谷P1616 疯狂的采药\n洛谷P1853 投资的最大效益\n3.多重背包\n种物品，体积背包\n物品体积，价值（每种最多选个）​\n\n洛谷P1776 宝物筛选\n4.分组背包\n组物品，体积背包\n组内每件物品体积价值每组物品种最多选个\n\n洛谷P1757 通天之分组背包\n洛谷P5322 排兵布阵\n求背包装得下的情况下的最大总价值\n讲解1.01背包\n种物品，体积背包\n物品体积，价值（最多只能用一次）\n\n思路：状态表示：前种物品花费体积得到的最大价值\n状态计算：第种物品选不选\n求最大价值：状态转移方程\n理解：从第种物品一件一件往后选，每一步都求所有体积下的最优解\n全局最优解一定会从前面的某个局部最优解转移过来\n例题：洛谷P1048 采药\n\n题目\n题目描述\n辰辰是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到一个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同的草药，采每一株都需要一些时间，每一株也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。”\n如果你是辰辰，你能完成这个任务吗？\n输入\n第一行有  个整数 （）和 （），用一个空格隔开， 代表总共能够用来采药的时间， 代表山洞里的草药的数目。\n接下来的  行每行包括两个在  到  之间（包括  和 ）的整数，分别表示采摘某株草药的时间和这株草药的价值。\n输出\n输出在规定的时间内可以采到的草药的最大总价值。\n样例输入\n123470 371 10069 11 2\n\n样例输出 \n13\n\n\n\n思路\n翻译题目\n总时间背包体积\n采每种药的时间物品体积\n\n状态表示：前种物品花费体积得到的最大价值\n状态计算：第种物品选不选\n求最大价值：状态转移方程\n\n代码如下：​\n1234567891011121314151617181920212223242526272829303132333435363738// 01背包// 状态表示 dp[i][j] 前i种j体积最大价值// 状态计算 dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - v[i]] + w[i])#include &lt;iostream&gt;using namespace std;const int N = 110, M = 1010;int n, V;int dp[N][M];int v[N], w[N]; // 我这里按照自己习惯定义的变量,可能和题目符号有些出入int main (){    cin &gt;&gt; V &gt;&gt; n;        for (int i = 1; i &lt;= n; i ++ )        cin &gt;&gt; v[i] &gt;&gt; w[i];        // 开始动态规划,从前往后一个一个挑    for (int i = 1; i &lt;= n; i ++ )         for (int j = 0; j &lt;= V; j ++ )        {            // 选到第i种,花费j体积            // 第i件没得选, 放不下            if (j &lt; v[i]) dp[i][j] = dp[i - 1][j];                        // 第i件有选或不选的权利            else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - v[i]] + w[i]);\t\t}        // 输出答案    cout &lt;&lt; dp[n][V] &lt;&lt; endl;        return 0;}\n\n\n\n优化还没完！还能再优化！🤭\n观察上面代码，我们发现在挑到第件物品时，我们只会用到第层的数据，而不会用到更前面的数据\n故可以把直接压缩到遍历到第种物品时，在第层的基础上更新到第层\n对于体积的直接保留原本的\n注意为了避免第层更新用的数据已经被更新过，这里体积需要从大到小枚举，读者可以自行体会\n\n优化后代码如下\n12345678910111213141516171819202122232425// 01背包1维#include &lt;iostream&gt;using namespace std;const int N = 110, M = 1010;int n, V;int dp[M];int v[N], w[N]; int main (){\tios::sync_with_stdio(false);\tcin.tie(0);\tcout.tie(0);        cin &gt;&gt; V &gt;&gt; n;    for (int i = 1; i &lt;= n; i ++ )        cin &gt;&gt; v[i] &gt;&gt; w[i];        for (int i = 1; i &lt;= n; i ++ )         for (int j = V; j &gt;= v[i]; j -- ) // 从大到小枚举,小于v[i]的更新不了        \tdp[j] = max(dp[j], dp[j - v[i]] + w[i]);        cout &lt;&lt; dp[V] &lt;&lt; endl;    return 0;}\n\n\n\n2.完全背包\n种物品，体积背包\n物品体积，价值（无限用）\n\n思路：模仿背包的思路，按照以下步骤\n状态表示：前种花体积的最大价值\n状态计算：背包的子状态是第种选没选完全背包可以无限选，子状态是第种选了个​\n转移方程：\n\n每一层都这样枚举，总体复杂度显然过于复杂了，需要进一步优化转移方程\n类似上面的，\n对比可得\n\n​\n如此一来便化简了许多\n优化：再考虑优化到维：\n第层需要用到第层和第层的数据，这不恰好是体积从小到大枚举得到的效果？\n体积从小到大枚举，第层枚举到时已经被更新为了而仍保留，符合题意\n所以和背包一样，这里也能压缩掉一维，只需体积从小到大枚举即可\n例题：洛谷P1616 疯狂的采药\n\n题目\n题目描述\nLiYuxiang 是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到一个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同种类的草药，采每一种都需要一些时间，每一种也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。”\n如果你是 LiYuxiang，你能完成这个任务吗？\n此题和原题的不同点：\n. 每种草药可以无限制地疯狂采摘。\n. 药的种类眼花缭乱，采药时间好长好长啊！师傅等得菊花都谢了！\n输入\n输入第一行有两个整数，分别代表总共能够用来采药的时间  和代表山洞里的草药的数目 。\n第  到第  行，每行两个整数，第  行的整数  分别表示采摘第  种草药的时间和该草药的价值。\n输出\n输出一行，这一行只包含一个整数，表示在规定的时间内，可以采到的草药的最大总价值。\n样例输入\n123470 371 10069 11 2\n\n样例输出\n1140\n\n\n\n代码如下：\n12345678910111213141516171819202122232425// 完全背包1维#include &lt;iostream&gt;using namespace std;const int N = 10010, M = 1e7+10;int n, V;long long int dp[M];long long  v[N], w[N]; int main (){\tios::sync_with_stdio(false);\tcin.tie(0);\tcout.tie(0);        cin &gt;&gt; V &gt;&gt; n;    for (int i = 1; i &lt;= n; i ++ )        cin &gt;&gt; v[i] &gt;&gt; w[i];        for (int i = 1; i &lt;= n; i ++ )         for (int j = v[i]; j &lt;= V; j ++ )        \tdp[j] = max(dp[j], dp[j - v[i]] + w[i]);        cout &lt;&lt; dp[V] &lt;&lt; endl;    return 0;}\n\n\n\n3.多重背包\n种物品，体积背包\n物品体积，价值（每种最多选个）​\n\n思路：状态表示：前种花体积的最大价值\n状态计算：子状态：第种选了个\n转移方程：\n\n总体复杂度当非常大时需要优化\n关键是从到枚举第种选了个效率太低了\n\n优化：优化思路：把第个物品用二进制拆成多种组合个个个 \n将每种物品的个单独看作一个物品\n则任意或\n进而再转化为背包问题这样对于每种物品最多只需要讨论个选与不选复杂度优化到\n思考为何这里不能用完全背包类似的优化思路\n例题：洛谷P1776 宝物筛选\n\n题目\n题目描述\n终于，破解了千年的难题。小 FF 找到了王室的宝物室，里面堆满了无数价值连城的宝物。\n这下小 FF 可发财了，嘎嘎。但是这里的宝物实在是太多了，小 FF 的采集车似乎装不下那么多宝物。看来小 FF 只能含泪舍弃其中的一部分宝物了。\n小 FF 对洞穴里的宝物进行了整理，他发现每样宝物都有一件或者多件。他粗略估算了下每样宝物的价值，之后开始了宝物筛选工作：小 FF 有一个最大载重为  的采集车，洞穴里总共有  种宝物，每种宝物的价值为 ，重量为 ，每种宝物有  件。小 FF 希望在采集车不超载的前提下，选择一些宝物装进采集车，使得它们的价值和最大。\n输入格式\n第一行为一个整数  和 ，分别表示宝物种数和采集车的最大载重。\n接下来  行每行三个整数 ​​。\n，，\n输出格式\n输出仅一个整数，表示在采集车不超载的情况下收集的宝物的最大价值。\n样例输入\n123454 203 9 35 9 19 4 28 1 3\n\n样例输出\n147\n\n\n\n代码如下：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 多重背包问题#include &lt;iostream&gt;using namespace std;const int N = 1e5 + 10, M = 4e4 + 10;int n, V;int dp[N];int v[N], w[N];int main(){    ios::sync_with_stdio(false);    cin.tie(0);    cout.tie(0);        cin &gt;&gt; n &gt;&gt; V;        int cnt = 1; // 存储拆分后的物品种数    int v1, w1, s1; // 未拆分    for (int i = 1; i &lt;= n; i ++ )    {        cin &gt;&gt; w1 &gt;&gt; v1 &gt;&gt; s1;                // s1拆成1+2+4+8+……        int k = 1;        while (s1 - k &gt; 0)        {            v[cnt] = v1 * k;            w[cnt ++] = w1 * k;            s1 -= k;            k *= 2;        }                // 拆剩下的        if(s1) v[cnt] = v1 * s1, w[cnt ++] = w1 * s1;\t}        n = cnt - 1;        // 01背包    for (int i = 1; i &lt;= n; i ++ )        for (int j = V; j &gt;= v[i]; j -- )        \tdp[j] = max(dp[j], dp[j - v[i]] + w[i]);        cout &lt;&lt; dp[V] &lt;&lt; endl;        return 0;}\n\n\n\n4.分组背包\n组物品，体积背包\n组内每件物品体积价值每组物品种最多选个​\n\n思路：状态表示前组花费体积的最大值\n状态计算子状态上一组选了哪一个\n状态转移方程\n\n优化至一维体积降序枚举略\n例题：洛谷P1757 通天之分组背包\n\n题目\n题目描述\n自  背包问世之后，小 A 对此深感兴趣。一天，小 A 去远游，却发现他的背包不同于  背包，他的物品大致可分为  组，每组中的物品相互冲突，现在，他想知道最大的利用价值是多少。\n输入\n两个数 ，表示一共有  件物品，总重量为 。\n接下来  行，每行  个数 ，表示物品的重量，利用价值，所属组数。\n，，， 在 int 范围内。\n输出\n一个数，最大的利用价值。\n样例输入\n123445 310 10 110 5 150 400 2\n\n样例输出\n110\n\n\n\n代码如下：\n123456789101112131415161718192021222324252627282930313233343536373839404142// 1维分组背包#include&lt;iostream&gt;using namespace std;const int N = 1e3 + 10;int dp[N];int n, V;int v[N][N], w[N][N], cnt[N];// cnt[]存每个组的物品数int main(){    ios::sync_with_stdio(false);    cin.tie(0);    cout.tie(0);    \tcin &gt;&gt; V &gt;&gt; n;\tint gm = 0;//存储最大组数    int v1, w1, j;\tfor (int i = 1; i &lt;= n; i ++ )\t{\t\tcin &gt;&gt; v1 &gt;&gt; w1 &gt;&gt; j;\t\tv[j][++ cnt[j]] = v1;\t\tw[j][cnt[j]] = w1;\t\tgm = max(gm, j);\t}    n = gm;    \t//开始动态规划\tfor (int i = 1; i &lt;= n; i ++ )\t\tfor (int j = V; j &gt;= 0; j -- )\t\t\tfor (int k = 0; k &lt;= cnt[i]; k ++ ) // 判断要选该组的哪件物品\t\t\t\tif(v[i][k] &lt;= j)\t\t\t\t\tdp[j] = max(dp[j], dp[j - v[i][k]] + w[i][k]);\tcout &lt;&lt; dp[V] &lt;&lt; endl;\treturn 0;}\n\n\n\n\n\n结语以上便是背包问题最基础的类模型，实际上的题目可能会结合上其他算法状态压缩、贪心、树形\n又或是进行变式求方案数多目标\n篇幅有限，笔者就不多赘述，相信凭借各位的聪明才智，一定可以轻松应付​(ง •_•)ง\n\n\n如果文中有任何错误之处，欢迎大家在评论区批评指正！🙏\n\n","slug":"动态规划-背包问题","date":"2024-09-26T05:12:09.000Z","categories_index":"算法","tags_index":"动态规划,背包问题","author_index":"Jerry"},{"id":"c3878449dce899402d13b06cc735de00","title":"博弈论--NIM游戏","content":"引入先介绍几个概念\n1.公平组合游戏ICG：\n两名玩家交替行动\n在任意时刻，可执行的行动与玩家本身无关（游戏公平性）\n不能行动的玩家输\n\n2.有向图游戏\n给定一个有向无环图，具有唯一的起点，玩家交替的把棋子沿有向边进行移动，每次移动一步，无法移动者输\n任何ICG均可化为有向图游戏\n\n3.先手必胜与先手必败\n在双方均完全理性的情况下，先手不必胜则必败，先手不必败则必胜\n\nNIM游戏：1.介绍NIM 游戏是一种经典的组合博弈，两名玩家轮流从若干堆石子中选择一堆，并从中取走任意数量的石子。无法继续操作的玩家判负。\n2.结论对堆石子\n先手必胜态：\n先手必败态：\n3.证明：由数学归纳，从特殊推向一般\n不能操作时，每堆都是，\n\n当，任意一步操作之后\n反证：对任意一步操作使\n若，\n设\n则\n则，但是，矛盾！！得证\n\n当，一定存在一步操作之后\n证明：设，设的最高位在第位\n则中必定存在至少的第位也为，且\n（若第位均为，则所有异或之后得到的第位也只能是，不合题意）\n所以可以从中拿走个石子（上一步证明了此步的合法性）\n故，得证\n\n所以在双方绝对理性的情况下，某一方拿完之后达到了异或值为的情况后，会一直握住这个状态，\n保证自己必胜。\n更详细的思路构造过程及证明请看编程之美_1.11 NIM（1）一排石头的游戏在线阅读\nSG函数1.Mex运算：设表示一个非负整数集合，定义为求出不属于集合的最小非负整数的运算，\n即：且\n2.SG函数将游戏的所有状态及其转换关系抽象成一张有向无环图\n定义终点，\n示例：\n\n\n图中模拟一堆个数为的石子的状态转移图，每次只能拿个或个石子，蓝色字为石子数，红色字为 \n对应状态的值\n \n由图：任何一个非状态都可以到，任何一个状态都到不了\n则先手拿完后对手总有办法后手让先手必败\n先手总有办法拿完使对手怎么拿都使先手必胜\n\n性质：\n对一个含多个图的游戏，取每个图起点的值\n则必胜，当\n必败，当\n3.证明：类似一般游戏\n，没有必胜的起点，则，必败\n\n存在，则我先手一定可以走一步到达，此时，对方 \n先手必败，即我方必胜\n\n：不全为的情况\n不管怎么走，，必将落入对方先手必胜局面，即我方必败\n分类NIM博弈的内容大致就这么多啦~\n来几道题目练练手,看看题目中是怎么变形的~\n基础变形\n洛谷P1247 取火柴游戏\n洛谷P7589 黑白棋   关键在翻译题目，本质就是简单的游戏\n洛谷P5675 取石子游戏    背包阶梯，代码不难理解，关键是想明白思路，考思维\n阶梯 Nim\n洛谷P3480 KAM-Pebbles  差分数组的阶梯\n洛谷P2575 高手过招\n\n\n如果文中有任何错误之处，欢迎大家在评论区批评指正！🙏\n\n","slug":"博弈论-NIM游戏","date":"2024-09-26T05:11:45.000Z","categories_index":"算法","tags_index":"博弈论,NIM游戏,SG函数","author_index":"Jerry"},{"id":"9fc7aaa29955e8777b63cdc5e2f3c111","title":"快速幂","content":"快速幂快速计算\n\n朴素计算 \n\n显然当过大时太慢了\n快速幂计算 思路\n即二进制\n所以\n\n\n\n\n而每次往后只需把平方一下就行\n代码123456789101112131415// 快速幂int qmi(int a, int k, int p){\t// 计算 a^k % p    int res = 1;    while (k)    {        // 判断ci是否为1,如果是就需要乘否则跳过        if (k &amp; 1) res = (long long)(res * a) % p; // 取模的乘法运算        k &gt;&gt;= 1;        a = (long long)(a * a) % p;    }        return res;}\n\n\n\n模板题洛谷P1226 快速幂\n应用求逆元\n逆元 除法的取模运算\n定义：若互质满足\n则称逆元记号，不是\n\n思路如下\n同乘约\n由费马定理\n\n模板题\n洛谷P3811 模意义下的乘法逆元\n结语由此，我们便有了乘除法的取模运算法则\n\n\n","slug":"快速幂","date":"2024-09-26T05:11:31.000Z","categories_index":"","tags_index":"快速幂,数论","author_index":"Jerry"},{"id":"40241814551b223b651e15683e69d116","title":"数学--约数","content":"约数1.求约数试除法求所有约数\n枚举\n对存\n代码：\n123456789101112vector&lt;int&gt; get_divisors(int x){    vector&lt;int&gt; res;    for (int i = 1; i &lt;= x / i; i ++ )        if (x % i == 0)        {            res.push_back(i);            if (i != x / i) res.push_back(x / i);        }    sort(res.begin(), res.end());    return res;}\n\n细节：存再排序比较方便\n2.约数个数 + 约数之和对任意自然数均可分解质因数为若干质数之积，即\n\n更新ing……\n","slug":"数学-约数","date":"2024-09-26T05:10:57.000Z","categories_index":"算法","tags_index":"数论,约数","author_index":"Jerry"},{"id":"6390ac85391cd221383c57783115e1e4","title":"数学--质数","content":"质数\n\n\n\n\n\n\n\n\n&gt;1 只包含1和本身两个约数\n1.判断质数试除法，只需枚举即可\n代码：\n12345678bool is_prime(int n){    if (n &lt; 2) return false;    for (int i = 2; i &lt;= n / i; i ++ )        if (x % i == 0)            return false;    return true;}\n\n细节\n①不推荐写要调用函数，太慢\n②不推荐写当太大时有可能溢出\n2.分解质因数最多只含一个的质因子，还是试除法，遇到约数就约掉\n如果约掉了所有的质因子之后仍，则约剩下的数必是质因子，单独处理即可\n代码：\n12345678910111213void divide(int n){    for (int i = 2; i &lt;= n / i; i ++ )        if (n % i == 0)        {            // 约掉所有因子，易证从小到大约掉的因子必是质因子            int s = 0;            while (x % i == 0) x /= i, s ++ ;            cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; s &lt;&lt; endl; // 输出质因子及其个数        }    if (x &gt; 1) cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; 1 &lt;&lt; endl; // 单独处理最后一个因子    cout &lt;&lt; endl;}\n\n\n\n3.筛质数给一个范围筛掉范围内所有的质数\n朴素筛法思路：\n从枚举，依次筛掉倍数，倍数，倍数，\n例题\n洛谷P5736 【深基7.例2】质数筛 \n埃氏筛法优化：\n只筛掉质数的倍数，如在中枚举到，已经在的时候就被筛了，就跳过不再筛的倍数了\n显然，如果枚举到某个数，在前面没被筛掉则必是质数 \n缺点：仍旧还是有些数被重复筛了，如会被和同时筛掉，效率仍待提高\n线性筛法优化：每个数只会被自己最小质因子筛掉，如在上面只会被筛掉\n伪代码：\n①一定是最小质因子一定是最小质因子\n②一定小于的所有质因子也一定是最小质因子\n③按照此逻辑来决定一个数一个数筛\n代码：\n123456789101112131415int primes[N], cnt;     // primes[]存储所有素数bool st[N];         // st[x]存储x是否被筛掉void get_primes(int n){    for (int i = 2; i &lt;= n; i ++ )    {        if (!st[i]) primes[cnt ++ ] = i;        for (int j = 0; primes[j] &lt;= n / i; j ++ )        {            st[primes[j] * i] = true;            if (i % primes[j] == 0) break;        }    }}\n\n例题\n洛谷P3383 【模板】线性筛素数\n\n\n如果文中有任何错误之处，欢迎大家在评论区批评指正！🙏\n\n","slug":"数学-质数","date":"2024-09-26T05:10:48.000Z","categories_index":"算法","tags_index":"数论,质数","author_index":"Jerry"},{"id":"23e5ccb93b471aba058840eff980504f","title":"图论--最短路","content":"最短路先贴张总体图：\n\n\n1.单源最短路(1)边权均为正数①朴素Dijkstra算法思路：\n\ndist[i]存到起点的最短距离（在执行过程更新），st[i]存是否已确定最短距离\n集合S已经确定最短距离的点集（实际上就是st[]为true的点）\n初始化所有点到起点距离均为无穷大，将起点到起点距离设置为0\n找当前所有未定最短距的点中的最近点t，用t更新其他点最短距离，并将t丢进集合S里\n迭代n次，即可确定所有点最短路\n\n步骤：\n下面用一个具体的例子来辅助解释这个过程\n\n初始化\n\n\n\n\n起点到起点的距离为，即\n\n\n\n\n遍历数组，找到一个节点，这个节点是：没有确定最短路的节点中距离起点最近的点。\n假设该节点编号为，此时就找到了起点到该节点的最短距离，置为\n\n\n\n\n\n遍历所有可以到达的节点，如果大于加上的距离\n即（为的距离），则更新\n\n\n\n\n\n\n\n一直重复上面的步骤直至所有点的最短路均被确定\n\n\n\n\n此时起点到所有点的最短路均被确定\n\n\n\n\n\n注意事项：\n复杂度：遍历次遍历个点找最近点\n稠密图，邻接矩阵存有向图\n当前情况需要每个点要求第一次出队的时候就已经确定最短路，所以要求图内不能有负权边\n（否则第一次出队可能不是最短路，则当前算法失效）\n伪代码：\n12345678int dist[n],state[n];dist[1] = 0, state[1] = 1;for(i:1 ~ n){    t &lt;- 没有确定最短路径的节点中距离源点最近的点;    state[t] = 1;    更新 dist;}\n\n\n\n代码模板：\n123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;int n;\t\t  // 点数int d[N][N];  // 邻接矩阵存有向图int dist[N];  // 存储1号点到每个点的最短距离bool st[N];   // 存储每个点的最短路是否已经确定// 求1号点到n号点的最短路，如果不存在则返回-1int dijkstra(){    memset(dist, 0x3f, sizeof dist);    dist[1] = 0;    for (int i = 0; i &lt; n - 1; i ++ )    {        int t = -1;     // 在还未确定最短路的点中，寻找距离最小的点        for (int j = 1; j &lt;= n; j ++ )            if (!st[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j]))                t = j;        // 用t更新其他点的距离        for (int j = 1; j &lt;= n; j ++ )            dist[j] = min(dist[j], dist[t] + d[t][j]);        st[t] = true;    }    if (dist[n] == 0x3f3f3f3f) return -1;    return dist[n];}\n\n\n\n②堆优化版Dijkstra算法思路：\n\n容易发现在朴素Dijkstra算法中，通过枚举来找最近点的操作值得优化，这里采用小根堆来存所有点当前离起点的最短路，堆顶即为最近点，这步操作的复杂度仅为 \n其余仍与朴素Dijkstra一样\n\n注意事项： \n复杂度：稀疏图，邻接表存有向图\n代码模板：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;typedef pair&lt;int, int&gt; PII;int n;      \t\t\t\t\t\t// 点的数量int h[N], w[N], e[N], ne[N], idx;   // 邻接表存储所有边int dist[N];        \t\t\t\t// 存储所有点到1号点的距离bool st[N];    \t\t\t\t\t \t// 存储每个点的最短距离是否已确定// 初始化邻接表void init(){    memset(h, -1, sizeof h);}// 连接有向边a→bvoid add(int a, int b, int c){    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;}// 求1号点到n号点的最短距离，如果不存在，则返回-1int dijkstra(){    memset(dist, 0x3f, sizeof dist); // 初始化距离为无穷大    dist[1] = 0;    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap; // 小根堆    heap.push({0, 1});      // first存储距离，second存储节点编号    while (heap.size())    {        auto t = heap.top(); // 取出最近点        heap.pop();        int ver = t.second, distance = t.first;        if (st[ver]) continue;        st[ver] = true;        for (int i = h[ver]; i != -1; i = ne[i])        {            int j = e[i];            if (dist[j] &gt; distance + w[i])            {                dist[j] = distance + w[i];                heap.push({dist[j], j});            }        }    }    if (dist[n] == 0x3f3f3f3f) return -1;    return dist[n];}\n\n\n\n！思考：为何Dijkstra只对非负权边有效，能举出例子证明吗？\n(2)存在负权边①Bellman-Ford算法思路：\n注意事项：\n\n复杂度\n\n代码模板：\n123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;int n, m;       // n表示点数，m表示边数int dist[N];        // dist[x]存储1到x的最短路距离struct Edge     // 边，a表示出点，b表示入点，w表示边的权重{    int a, b, w;}edges[M];// 求1到n的最短路距离，如果无法从1走到n，则返回-1。int bellman_ford(){    memset(dist, 0x3f, sizeof dist);    dist[1] = 0;    // 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。    for (int i = 0; i &lt; n; i ++ )    {        for (int j = 0; j &lt; m; j ++ )        {            int a = edges[j].a, b = edges[j].b, w = edges[j].w;            if (dist[b] &gt; dist[a] + w)                dist[b] = dist[a] + w;        }    }    if (dist[n] &gt; 0x3f3f3f3f / 2) return -1;    return dist[n];}\n\n\n\n②SPFA算法思路：\n注意事项：\n\n复杂度一般，最多\n代码短，非负权边的情况一般也能用，但是容易被卡，建议还是在存在负权边时才用\n要求一定不含负环！！！！！\n\n代码模板：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;int n;      \t\t\t\t\t\t\t// 总点数int h[N], w[N], e[N], ne[N], idx;       // 邻接表存储所有边int dist[N];        \t\t\t\t\t// 存储每个点到1号点的最短距离bool st[N];     \t\t\t\t\t\t// 存储每个点是否在队列中void init(){    memset(h, -1, sizeof h);}// 连接a→b的有向边void add(int a,int b, int c){    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;}// 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1int spfa(){    memset(dist, 0x3f, sizeof dist);    dist[1] = 0;    queue&lt;int&gt; q;    q.push(1);    st[1] = true;    while (q.size())    {        auto t = q.front();        q.pop();        st[t] = false;        for (int i = h[t]; i != -1; i = ne[i])        {            int j = e[i];            if (dist[j] &gt; dist[t] + w[i])            {                dist[j] = dist[t] + w[i];                if (!st[j])     // 如果队列中已存在j，则不需要将j重复插入                {                    q.push(j);                    st[j] = true;                }            }        }    }    if (dist[n] == 0x3f3f3f3f) return -1;    return dist[n];}\n\n\n\n2.多源最短路Floyd算法思路：注意事项：代码：1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int INF = 0x3f3f3f3f;int d[N][N]; // 邻接矩阵存距离// 初始化void init(){\tfor (int i = 1; i &lt;= n; i ++ )        for (int j = 1; j &lt;= n; j ++ )            if (i == j) d[i][j] = 0;            else d[i][j] = INF;}// 算法结束后，d[a][b]表示a到b的最短距离void floyd(){    for (int k = 1; k &lt;= n; k ++ )        for (int i = 1; i &lt;= n; i ++ )            for (int j = 1; j &lt;= n; j ++ )                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);}\n\n","slug":"图论-最短路","date":"2024-09-26T05:09:40.000Z","categories_index":"算法","tags_index":"最短路,图论,Dijkstra,SPFA,Bellman-Ford,Floyd","author_index":"Jerry"},{"id":"708fa6adfa46361c793158b58a61f772","title":"bfs","content":"宽度优先搜索\n待更新…………\n模型\nFlood Fill\n多源bfs\n双端队列bfs\n双向广搜\nA*\n","slug":"bfs","date":"2024-09-26T05:09:28.000Z","categories_index":"","tags_index":"","author_index":"Jerry"},{"id":"c0864a7ed82c2e6dd4eb8a34dacd4941","title":"dfs","content":"深度优先搜索\n想了一下dfs还是挺杂的，近期可能暂时整理不完啦，丢几个关键词，后续计划更新\n判断连通性\n剪枝\n\n可行性\n最优性\n估测性-预测未来\n\n迭代加深—早回头\n双向DFS\nIDA*\n","slug":"dfs","date":"2024-09-26T05:09:23.000Z","categories_index":"","tags_index":"","author_index":"Jerry"},{"id":"f897c3d44f1ea027302ceab6694fc628","title":"单调队列与单调栈","content":"","slug":"单调队列与单调栈","date":"2024-09-26T05:09:03.000Z","categories_index":"","tags_index":"","author_index":"Jerry"},{"id":"c18469ab20e7b093d36b4a61728d07eb","title":"并查集","content":"并查集（Union-Find）概述并查集是一种高效的数据结构，以多棵树的形式存储，每棵树有一个被打上标记的根节点\n主要用途：\n\n合并两个集合\n查询元素所属的集合\n\n常见题型：\n\n朴素并查集\n带权并查集\n维护size并查集\n\n数据结构并查集通常使用三个数组实现：\n\np[] (parent)数组：记录每个元素的父节点。\nd[] (distanse)数组：记录每个元素到父节点距离\nsize[]数组：记录每个并查集的大小\n\nps:虽然并查集在逻辑结构上是一棵棵在同一集合的树，但是存储结构仍可以用普通的数组实现\n操作1.建立初始化并查集\n并查集根节点root:的标记方式p[root] = root\n表示根节点的父节点就是自己\n123456void init()&#123;\t// 一开始每个节点各自为营\tfor (int i = 1; i &lt;= n; i ++ )\t\tp[i] = i;&#125; \n\n2.查找查找元素 x 所在集合的根节点：\n这里有个优化，利用递归在查找的时候就直接把每个节点的父节点压缩向了祖宗节点，此时距离d也更新为了到父节点(祖宗节点)的距离\n1234567891011int find(int x)&#123;    if (p[x] != x) p[x] = find(p[x]);    // p[x]效果为找x的祖宗节点    // 这里调用p[x] = find(p[x])直接让x的父节点指向了p[x]的祖宗节点    // 经过层层递归会最终指向整棵树的根节点    int root = find(p[x]);     // 先要存root是因为只有先跑find()才能让d[p[x]]变为p[x]到祖宗节点的距离    d[x] += d[p[x]];    return root;&#125;\n\n3.合并合并两棵树：\n12345678910111213void merge(int x, int y)&#123;\t// 找出两棵树的根节点\tint px = find(x), py = find(y);\t\t// 根节点不同才需要合并\tif (px != py)     &#123;\t\tp[px] = py;        size[py] += size[px];        // 可能还需要对d[px]进行操作,具体情形依题目而定\t&#125;&#125;\n\n至此，并查集的基本操作均已介绍完毕，操作简洁作用大，用处这么大的数据结构上哪里找呀~\n来几道例题尝试尝试~\n例题朴素并查集\n洛谷 P3367 【模板】并查集\n\n\n维护size的并查集\n洛谷P1455 搭配购买\n\n\n维护到祖宗节点距离的并查集(带权并查集)\n 洛谷P1196 银河英雄传说\n 洛谷P2024食物链 \n\n\n如果文中有任何错误之处，欢迎大家在评论区批评指正！🙏\n\n\n\n","slug":"并查集","date":"2024-09-26T05:08:52.000Z","categories_index":"数据结构","tags_index":"并查集","author_index":"Jerry"},{"id":"a448dfd8ebb4408d1633f0dff8411f1c","title":"线段树","content":"线段树（Segment Tree）概述线段树是一种高效的数据结构，用于解决区间查询和更新问题。它能够在 (O(\\log n)) 时间复杂度内完成以下操作：\n\n查询区间和\n更新区间元素\n\n线段树特别适用于需要频繁处理区间查询和动态更新的场景。\n数据结构线段树通常使用完全二叉树的形式存储，节点表示数组的不同区间。假设原数组为 A，线段树为 ST，则每个节点 ST[node] 表示数组 A 的某个区间的值。\n操作1. 建树操作构建线段树的过程如下：\ndef build(A, ST, node, start, end):\n    if start == end:\n        ST[node] = A[start]  # 叶子节点\n    else:\n        mid = (start + end) // 2\n        build(A, ST, 2 * node + 1, start, mid)  # 构建左子树\n        build(A, ST, 2 * node + 2, mid + 1, end)  # 构建右子树\n        ST[node] = ST[2 * node + 1] + ST[2 * node + 2]  # 计算节点值\n","slug":"线段树","date":"2024-09-26T05:05:40.000Z","categories_index":"数据结构","tags_index":"线段树","author_index":"Jerry"},{"id":"7ff326fdf142ec1868a8e7b87c57157c","title":"基础数据结构","content":"链表链表是一种线性数据结构，由一系列节点组成，每个节点包含数据部分和指向下一个节点的指针。链表的优点是插入和删除操作效率高，但随机访问的效率较低。根据节点的连接方式，链表可分为以下几种类型：\n\n单向链表：每个节点指向下一个节点。\n双向链表：每个节点既指向下一个节点，又指向前一个节点。\n循环链表：最后一个节点指向头节点，形成一个环。\n\n栈栈是一种后进先出（LIFO）的数据结构，插入和删除操作都发生在同一端，称为栈顶。常用的栈操作包括：\n\npush：将元素压入栈顶。\npop：从栈顶弹出元素。\npeek：查看栈顶元素但不弹出。\n\n栈在函数调用管理、表达式求值等场景中广泛应用。\n队列队列是一种先进先出（FIFO）的数据结构，插入操作发生在队尾，删除操作发生在队头。常用的队列操作包括：\n\nenqueue：将元素插入队尾。\ndequeue：从队头删除元素。\nfront：查看队头元素但不删除。\n\n队列常用于任务调度、打印任务管理等场景。\n堆堆是一种特殊的树形数据结构，满足堆性质：在最大堆中，父节点的值大于或等于其子节点的值；在最小堆中，父节点的值小于或等于其子节点的值。堆的主要特点包括：\n\n插入：将新元素添加到堆中后，进行上浮操作维护堆性质。\n删除：删除堆顶元素后，将最后一个元素移至堆顶，进行下沉操作维护堆性质。\n\n堆常用于实现优先队列和高效的排序算法（如堆排序）。\n","slug":"基础数据结构","date":"2024-09-26T05:01:20.000Z","categories_index":"数据结构","tags_index":"链表,栈,队列,堆","author_index":"Jerry"},{"id":"36ef81d64d1d0edc64820d5afd16a0b4","title":"树状数组","content":"树状数组（Fenwick Tree）概述树状数组是一种用于高效处理动态数组中前缀和查询的数据结构。它能够在 (O(\\log n)) 时间复杂度内完成以下操作：\n\n更新数组中的元素O(logn)\n查询数组前缀和O(logn)\n\n数组： O(1) 更新，O(n) 前缀和\n前缀和数组：  O(n) 更新，O(1) 前缀和\n如果问题同时要大量更新和求前缀和，上述两种数据结构均会寄掉\n树状数组则采取折中思路，把整体复杂度降低至O(logn)\n数据结构先放张整体结构图：\n\n\n\n\n核心思想：二进制\n对任意数x可将其二进制分解\n其中\n从而将区间(0, x]分为以下几个部分：\n长度\n长度\n长度\n长度\n容易发现，对于任意一段区间(L,R]\n区间长度为lowbit(x),区间左端点L = R - lowbit(R)\n则在上述规则下，只要确定右端点，左端点的信息也唯一确定\n\n树状数组用一个数组来存储序列的信息:\ntr[x]：存储序列在[x - lowbit(x) + 1, x]之间的数的片段和\n则按照前面的区间划分规则\n\n看到公式的第三行，很容易想到可以用递归来实现，只需每层往下不断-lowbit(t)就行\nx最多只有logx位1，所以树状数组求前缀和的操作复杂度是O(logn)\n类似的，若要实现在原数组第x位上添加c均需添加c(可能这个结论不是那么明显，读者可自行思考其中的原理，后续笔者将补充上证明)\n当然这里不会无穷往后面加，我们只需用到1~n的数据，当加到超过n就可以停了，故整该操作的复杂度仍旧为O(logn)（分析同求和\n一个更容易理解的视频讲解\n操作1. lowbit运算复杂度：O(1)\n代码如下，大家可以自行找几个数验证一下\n12345int lowbit(int x){    // 取出x的最后一位1    return x &amp; -x;}\n\n\n\n2.添加复杂度：O(logn)\n123456int add(int x, int c){\t// 向第x位添加c,c可正可负\t// 对所有含第x位的树节点均加上c\tfor (int i = X; i &lt;= n; i += lowbit(i)) tr[i] += c;}\n\n\n\n3.前缀和复杂度：O(logn)\n1234567int sum(int x){\t// 对第1~x位求和\t// 计算当前数存的值,然后迭代求剩余节点的值\tif (!x) return 0;\treturn tr[x] + sum(x - lowbit(x));}\n\n\n\n\n\n例题洛谷 P10589 楼兰图腾\n\n题目\n题目描述\n在完成了分配任务之后，西部 314 来到了楼兰古城的西部。相传很久以前这片土地上（比楼兰古城还早）生活着两个部落，一个部落崇拜尖刀（V），一个部落崇拜铁锹（∧），他们分别用 V 和 ∧ 的形状来代表各自部落的图腾。\n西部 314 在楼兰古城的下面发现了一幅巨大的壁画，壁画上被标记出了  个点，经测量发现这  个点的水平位置和竖直位置是两两不同的。西部 314 认为这幅壁画所包含的信息与这  个点的相对位置有关，因此不妨设坐标分别为 ，其中  是  到  的一个排列。\n\n如图，图中的 ，，，，。\n西部 314 打算研究这幅壁画中包含着多少个图腾，其中 V 图腾的定义如下（注意：图腾的形式只和这三个纵坐标的相对大小排列顺序有关） 且 , ；\n而崇拜 ∧ 的部落的图腾被定义为  且 ，；\n西部 314 想知道，这  个点中两个部落图腾的数目。因此，你需要编写一个程序来求出 V 的个数和 ∧ 的个数。\n输入\n第一行一个正整数 ；\n第二行是  个正整数，分别代表 ​。\n，答案不超过 。\n输出\n输出两个数，中间用空格隔开，依次为 V 的个数和 ∧ 的个数\n样例输入 #1\n1251 5 3 2 4\n\n样例输出 #1\n13 4\n\n\n\n\n题解\n思路\n对字形图腾，只需要知道每个点前后各有多少个比它高的字形反之\n朴素思路是枚举到第个点，再一一枚举前后比它高的元素复杂度需要优化\n想象有这么一个的数轴我从左往右一一读取每个点读完一个点就在数轴上标记 \n则每个点左边比自己高的点数量其实就是前缀和\n而右边的只需从右往左一一读取再来一遍就行\n\n然而这个前缀数组需要一直修改尽管我们可以用的时间读出高点但是需要的时间去维护它\n复杂度仍旧是这就让我们想到了树状数组更新和求和复杂度均为\n树状数组优化后复杂度变为满足要求\n代码如下\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// 利用树状数组存储某个数左/右 大于/小于它自己的数的数量#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;const int N = 2e5 + 10;int n;int a[N];int tr[N];int gre[N], low[N]; // 存储LL res1, res2;inline int lowbit(int x){    return x &amp; (-x);}inline int sum(int x){    // 求前x项的和    if (!x) return 0;    return tr[x] + sum(x - lowbit(x));}inline void add(int x, int c){    for (int i = x; i &lt;= n; i += lowbit(i)) tr[i] += c;}int main(){    scanf(\"%d\", &amp;n);        for (int i = 1; i &lt;= n; i ++ )        scanf(\"%d\", &amp;a[i]);            // 从左到右来一遍    for (int i = 1; i &lt;= n; i ++ )    {        int y = a[i];        gre[i] = sum(n) - sum(y); // 统计在i左边y + 1到n的数的数量        low[i] = sum(y - 1); // 统计在i左边1到y - 1的数的数量        add(y, 1); // 插入这个数    }        memset(tr, 0, sizeof tr);        // 从右到左再来一遍    for (int i = n; i; i --)    {        int y = a[i];        res1 += (LL)gre[i] * (sum(n) - sum(y));        res2 += (LL)low[i] * (sum(y - 1));        add(y, 1);    }            printf(\"%lld %lld\", res1, res2);        return 0;    }\n\n\n\nPOJ 2182 迷路的奶牛  从后往前慢慢确定每头牛高度树状数组前缀和二分\nPOJ 3468  A Simple Problem with Integers  维护两个前缀和数组的树状数组\n\n\n如果文中有任何错误之处，欢迎大家在评论区批评指正！🙏\n\n\n\n","slug":"树状数组","date":"2024-09-26T04:54:35.000Z","categories_index":"数据结构","tags_index":"树状数组,lowbit,前缀和","author_index":"Jerry"},{"id":"8038215b5c2b5aa82664c7d7c50d2cdc","title":"二分","content":"二分\n\n\n\n\n\n\n注意\n❗❗❗❗二分查找的前提是被查找的数据必须有二段性\n\n如何理解这句话呢？\n举个例子，在数组[1, 5 , 8, 9, 23, 25, 40]里找9\n我可以让check标准为&lt;=9，则转化为找数组中&lt;=9最大值\n对于9左边的数，均小于等于9,而对于9右边的数，均大于9\n目标答案的两边一边满足check一边不满足check，这便是二段性的含义\n绝大多数时候，二段性均不明显，需要通过自行定义check标准把二段性弄出来，需要积累一定的题量\n核心思想二分查找通过不断缩小查找范围，每次将范围缩小一半，最终定位目标元素的位置。\n算法思路\n初始化边界\n\n进入二分，check(mid)\n\n重复操作\n\n\n核心：不断折半折半查找的关键在于通过不断折半查找区间，可以大幅度减少查找次数，效率为 O(log n)\n代码模板：二分的模板不唯一，关键就是要判断好循环终止条件和划分好折半区间的边界，避免死循环\n这里放一个我一直在用的模板\n整数二分\n123456789101112131415161718192021// 模板1：check选左bool check(int x){\t// 定义check标准\tif (……) return false;\treturn true;}int main(){    int l = L, r = R; // 初始化边界    int mid;    while (l &lt; r)    {        mid = l + r &gt;&gt; 1;        if (check(mid)) r = mid;        else l = mid + 1;    }    cout &lt;&lt; l &lt;&lt; endl;}\n\n123456789101112131415161718192021// 模板2: check选右bool check(int x){\t// 定义check标准\tif (……) return false;\treturn true;}int main(){    int l = L, r = R;    int mid;    while (l &lt; r)    {        mid = l + r + 1 &gt;&gt; 1;        if (check(mid)) l = mid;        else r = mid - 1;    }    cout &lt;&lt; l &lt;&lt; endl;}\n\n\n\n小数二分\n12345678910111213141516171819bool check(double x){\t// 定义check标准\tif (……) return false;\treturn true;}int main(){\tconst double eps = 1e-6; // 设置精度\tdouble l = L, r = R;\tdouble mid;\twhile (r - l &gt; eps)    {    \tmid = (l + r) / 2;    \tif (check(mid)) r = mid;    \telse l = mid;    }}\n\n\n\n例题洛谷P1083 借教室\n\n题目\n题目描述\n在大学期间，经常需要租借教室。大到院系举办活动，小到学习小组自习讨论，都需要向学校申请借教室。教室的大小功能不同，借教室人的身份不同，借教室的手续也不一样。\n面对海量租借教室的信息，我们自然希望编程解决这个问题。\n我们需要处理接下来  天的借教室信息，其中第  天学校有  个教室可供租借。共有  份订单，每份订单用三个正整数描述，分别为 ，表示某租借者需要从第  天到第  天租借教室（包括第  天和第  天），每天需要租借  个教室。\n我们假定，租借者对教室的大小、地点没有要求。即对于每份订单，我们只需要每天提供  个教室，而它们具体是哪些教室，每天是否是相同的教室则不用考虑。\n借教室的原则是先到先得，也就是说我们要按照订单的先后顺序依次为每份订单分配教室。如果在分配的过程中遇到一份订单无法完全满足，则需要停止教室的分配，通知当前申请人修改订单。这里的无法满足指从第  天到第  天中有至少一天剩余的教室数量不足  个。\n现在我们需要知道，是否会有订单无法完全满足。如果有，需要通知哪一个申请人修改订单。\n输入格式\n第一行包含两个正整数 ，表示天数和订单的数量。\n第二行包含  个正整数，其中第  个数为 ，表示第  天可用于租借的教室数量。\n接下来有  行，每行包含三个正整数 ，表示租借的数量，租借开始、结束分别在第几天。\n每行相邻的两个数之间均用一个空格隔开。天数与订单均用从  开始的整数编号。\n\n输出格式\n如果所有订单均可满足，则输出只有一行，包含一个整数 。否则（订单无法完全满足）\n输出两行，第一行输出一个负整数 ，第二行输出需要修改订单的申请人编号。\n样例输入 #1\n123454 3 2 5 4 3 2 1 3 3 2 4 4 2 4\n\n样例输出 #1\n12-1 2\n\n\n\n题解\n思路\n题目给的变量比较多，大致是这个意思：\n已知天的课室数量分布，份订单每份订单交代了天需要个课室\n从第份订单往后处理，判断哪个订单开始满足不了​\n\n朴素想法是枚举第份订单，然后判断加了订单之后天有没有哪天是满足不了的\n复杂度显然需要优化\n刚好二分可以带来一个的优化，刚好在允许范围内\n\n二分思路：无法满足的最早的一笔订单 \n这份订单前的订单都可以满足包括这份订单之后的都无法满足符合二段性\n这里可以用差分组优化来存储前份订单的数据\n代码如下：\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;typedef long long LL;const int N = 1e6 + 10;int n, m;LL R[N]; // 每天的课室数LL b[N]; // n天需要教室数量的差分数组struct {\tLL d;\tint s, t;} T[N]; // 订单bool check(int x){\t// 判断前x份订单是否能满足\t// 重置差分数组\tmemset(b, 0, sizeof b);\tfor (int i = 1; i &lt;= x; i++)\t\tb[T[i].s] += T[i].d, b[T[i].t + 1] -= T[i].d;\t// 差分数组求前缀和得每天需求量\tfor (int i = 1; i &lt;= n; i++) b[i] += b[i - 1];\t// 检测是否哪天完不成\tfor (int i = 1; i &lt;= n; i++)\t\tif (b[i] &gt; R[i]) return true;\treturn false;}int main(){\tios::sync_with_stdio(false);\tcin.tie(0);\tcout.tie(0);\tcin &gt;&gt; n &gt;&gt; m;\tfor (int i = 1; i &lt;= n; i++) cin &gt;&gt; R[i];\tfor (int i = 1; i &lt;= m; i++) cin &gt;&gt; T[i].d &gt;&gt; T[i].s &gt;&gt; T[i].t;\t// 开始二分\tint l = 1, r = m + 1;\tint mid;\twhile (l &lt; r)\t{\t\t// 找到无法满足的订单里最小的一笔\t\tmid = l + r &gt;&gt; 1;\t\tif (check(mid)) r = mid;\t\telse l = mid + 1;\t}\t// 都可满足\tif (l == m + 1) puts(\"0\");\telse cout &lt;&lt; -1 &lt;&lt; endl &lt;&lt; l &lt;&lt; endl;\treturn 0;}\n\n\n\n\n洛谷P3743 小鸟的设备\n\n题目\n题目描述\n小鸟有  个可同时使用的设备。第  个设备每秒消耗  个单位能量。能量的使用是连续的，也就是说能量不是某时刻突然消耗的，而是匀速消耗。也就是说，对于任意实数，在  秒内消耗的能量均为  单位。在开始的时候第  个设备里存储着  个单位能量。\n同时小鸟又有一个可以给任意一个设备充电的充电宝，每秒可以给接通的设备充能  个单位，充能也是连续的，不再赘述。你可以在任意时间给任意一个设备充能，从一个设备切换到另一个设备的时间忽略不计。\n小鸟想把这些设备一起使用，直到其中有设备能量降为  。所以小鸟想知道，在充电器的作用下，她最多能将这些设备一起使用多久。\n输入\n第一行给出两个整数 。\n接下来  行，每行表示一个设备，给出两个整数，分别是这个设备的  和 ​。\n，，。\n输出格式\n如果小鸟可以无限使用这些设备，输出 。\n否则输出小鸟在其中一个设备能量降为  之前最多能使用多久。\n设你的答案为 ，标准答案为 ，只有当  满足 的时候，你能得到本测试点的满分。\n样例输入 #1\n1232 12 22 1000\n\n样例输出 #1\n12.0000000000\n\n样例输入 #2\n121 1001 1\n\n样例输出 #2\n1-1\n\n样例输入 #3\n12343 54 35 26 1\n\n样例输出 #3\n10.5000000000\n\n\n\n\n题解\n思路\n能量连续使用，提醒我们这是小数二分\n二分思路找到无法使用的最短时间\n代码如下\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const double eps = 1e-6; //设置精度const int N = 1e5 + 10;int n;double p;double a[N], b[N];bool check(double x){    // 不能完成返回真,能完成返回假    double res = 0;    for (int i = 1; i &lt;= n; i++)    {        res -= min(b[i] - a[i] * x, 0.0);    }    return res &gt; p * x;}int main(){    ios::sync_with_stdio(false);    cin.tie(0);    cout.tie(0);    cin &gt;&gt; n &gt;&gt; p;    for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i] &gt;&gt; b[i];    double l = 0, r = 10000000001; // 设置最大边界,估一下大概在10^10量级    double mid;    while (r - l &gt; eps)    {        // 二分无法使用的最小值        mid = (l + r) / 2;        if (check(mid)) r = mid;        else l = mid;    }    if (r &gt; 10000000000) puts(\"-1\");    else cout &lt;&lt; l &lt;&lt; endl;    return 0;}\n\n\n\n洛谷P9240 冶炼金属 \n\n\n进阶一点\n洛谷P1314 聪明的质监员\n洛谷P1948 Telephone Lines S 找一条连接起点终点的路径，使得第长的边最小分\n\n\n 如果文中有任何错误之处，欢迎大家在评论区批评指正！ 🙏\n\n","slug":"二分","date":"2024-09-26T02:50:13.000Z","categories_index":"算法","tags_index":"基础算法,二分","author_index":"Jerry"},{"id":"2a1893ca085cc0c5b7d1cdcd8c0b1c91","title":"排序","content":"1.快速排序对数组 q 在下标 l 到 r 的范围内进行升序排序。\n快速排序通过多次的比较和交换，在一趟排序之中确定好选择的基准应该在的位置。这个位置满足的条件是：\n\n它的左边的数都小于它。\n它的右边的数都大于它。\n\n之后对左右的区间进行递归排序，最后所有的数都位于它应该在的地方，排序完成。\n排序思路\n确定分界点 x ：\n\n选择 x 为 q[l]、q[r] 或 q[(l + r) / 2] 中的任意一个。\nps: x可以任取，一般取为q[ l + r &gt;&gt; 1]\n\n\n\n调整数组：\n\nq[l] 到 q[x-1] 中的元素都小于 x，\nq[x+1] 到 q[r] 中的元素都大于或等于 x。\n\n\n递归处理子区间：\n\n\n核心操作双指针：\n\n设置两个指针，i 和 j，分别指向当前区间的头和尾。\n两个指针向中间移动，遇到不满足条件的元素(需要交换)时停止。\n交换这两个指针指向的元素，然后继续移动指针，直到它们相遇。\n\n注意事项\n在判断条件时要确保准确，避免死循环→注意前面的最前面的return判断\n确定好每次递归的区间，确保排序的完整性。\n时间复杂度O(nlogn)\n\n代码：12345678910111213141516void quick_sort(int q[], int l, int r)&#123;\tif (l &gt;= r) return; // 排序完成,返回\tint x = q[l + r &gt;&gt; 1], i = l - 1, j = r + 1;\twhile (i &lt; j)    &#123;\t\t// 当两个指针未相遇时,一直移动直至需要交换    \tdo i ++; while(q[i] &lt; x);    \tdo j --; while(q[j] &gt; x);    \tif (i &lt; j) swap(q[i], q[j]); // 交换    \t    \t// 分治子区间    \tquick_sort(q, l, j);    \tquick_sort(q, j + 1, r);    &#125;&#125;\n\n直接理解可能还是有点抽象，也许你会觉得好像寻找分界点让左小又大能有一定的排序作用，但是get不到为什么这样一通操作能保证全体点都严格排好序，找到了张动态图给大家参考一下~\n\n2.归并排序对数组 q 在下标 l 到 r 的范围内进行升序排序。\n核心思想分治\n排序思路\n确定分界点mid：\n\nmid = (l + r) / 2，将数组分为两部分。\n\n\n递归排序：\n\n递归地对 q[l] ~ q[mid] 和 q[mid+1] ~ q[r] 两部分进行排序，此时两部分已各自有序→当前需要进行的操作仅为归并已经排好的两段区间\n\n\n合并：\n\n\n核心操作双指针：\n\n指针分别指向两部分的头部。\n比较两部分当前指针指向的元素，将较小的复制到一个新的数组中。\n当其中一部分复制完后，将另一部分剩余的元素全部复制到新数组。\n将合并后的新数组复制回原数组。\n\n注意事项\n递归时需要确保左右部分的区间划分正确。\n时间复杂度O(nlogn)\n\n代码：12345678910111213141516171819202122232425262728const int N = 1e6 + 10; // 根据具体题目定数量级int tmp[N]; // 用来临时存归并完的数组void merge_sort(int q[], int l, int r)&#123;\tif (l &gt;= r) return; // 排序完成,返回\t\tint mid = l + r &gt;&gt; 1;\t\t// 排序好子区间\tmerge_sort(q, l, mid), merge_sort(q, mid + 1, r);\t\t// 合并\tint i = l, j = mid + 1, k = 0;\tint tmp[N];\twhile (i &lt;= mid &amp;&amp; j &lt;= r)\t&#123;\t\tif (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];\t\telse tmp[k ++ ] = q[j ++ ];\t&#125;\t\twhile (i &lt;= mid) tmp[k ++ ] = q[i ++ ];\twhile (j &lt;= r) tmp[k ++ ] = q[j ++ ];\t\t// 把排完序的数组拷贝回去\tfor (i = l, k = 0; i &lt;= r;) q[i ++ ] = q[k ++ ];&#125;\n\n归并排序在大一的程设中也有出现喔，这里贴个图模拟一下排序的流程~\n\n排序模板题：洛谷 P1177 归并排序\n洛谷P1908 逆序对\n\n\n 如果文中有任何错误之处，欢迎大家在评论区批评指正！🙏\n\n\n","slug":"排序","date":"2024-09-26T02:05:17.000Z","categories_index":"算法","tags_index":"基础算法,快速排序,归并排序","author_index":"Jerry"},{"id":"b70cb6e2fe5cd3e70bacd823f6f633fc","title":"近期规划","content":"欢迎来到我的小天地！🎉嘿，欢迎来到我的小天地！这是一个属于技术与灵感碰撞的角落，无论你是路过还是驻足，都希望这儿能给你带来点什么有趣的东西。\n关于这个博客这个博客就像是我脑海里的“小宇宙”——技术、算法、科研，以及生活里的灵感火花。我想在这里和大家分享自己的探索，可能会有些前端、后端的技术总结，算法题目挑战的记录，项目笔记及日常随笔。\n你可以期待什么？未来这里会不断更新关于技术的思考、算法题的解题策略，也许还会时不时出现一些歌曲推荐 🎸 或者跑步训练随笔 🏃。你可以期待这里每一篇文章都带来一点灵感和乐趣！\n一起互动吧！如果你对某个技术话题感兴趣，或者也喜欢讨论算法问题，随时留言！我非常期待与你的互动。别害羞，我的评论区永远欢迎你！🙌\n\n好了，不多剧透了，先看文章吧！希望你每次来访都能有所收获，并愿意常来坐坐 😊。\n","slug":"近期规划","date":"2024-09-26T01:49:54.000Z","categories_index":"公告","tags_index":"","author_index":"Jerry"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post1$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server1$ hexo server\n\nMore info: Server\nGenerate static files1$ hexo generate\n\nMore info: Generating\nDeploy to remote sites1$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2024-09-25T08:52:32.921Z","categories_index":"博客","tags_index":"博客部署","author_index":"Jerry"}]